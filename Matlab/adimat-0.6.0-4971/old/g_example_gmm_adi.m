% Generated by ADiMat 0.6.0-4728
% Copyright 2009-2013 Johannes Willkomm, Fachgebiet Scientific Computing,
% TU Darmstadt, 64289 Darmstadt, Germany
% Copyright 2001-2008 Andre Vehreschild, Institute for Scientific Computing,
% RWTH Aachen University, 52056 Aachen, Germany.
% Visit us on the web at http://www.adimat.de
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%
%                             DISCLAIMER
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOLOCALCSE  -- Do not use local common subexpression elimination when
%		 canonicalizing the code.
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% NOPRESCALARFOLDING -- Switch off folding of scalar constants before
%		 augmentation.
% NOPOSTSCALARFOLDING -- Switch off folding of scalar constants after
%		 augmentation.
% NOCONSTFOLDMULT0 -- Switch off folding of product with one factor
%		 being zero: b*0=0.
% FUNCMODE    -- Inputfile is a function (This flag can not be set explicitly).
% NOTMPCLEAR  -- Suppress generation of clear g_* instructions.
% UNBOUND_XML  -- Write list of unbound identifiers in XML format.
% DEPENDENCIES_XML  -- Write list of functions in XML format.
% UNBOUND_ERROR	-- Stop with error if unbound identifiers found (default).
% FUNCTION_LIST_XML	-- Write list of functions to XML file.
% VERBOSITYLEVEL=5
% AD_IVARS= alphas, mus, Ls
% AD_DVARS= nll


function [g_nll, nll]= g_example_gmm_adi(g_alphas, alphas, g_mus, mus, g_Ls, Ls, x)
   K= length(alphas); 
   lse= zeros(K, 1, 'like', alphas); 
   g_lse= g_zeros(size(lse));
   for k= 1: K
      g_tmp_Ls_00000= g_Ls(: , : , k);
      tmp_Ls_00000= Ls(: , : , k);
      g_L0= g_tmp_Ls_00000;
      L0= tmp_Ls_00000; 
      g_tmp_tril_00000= call(@tril, g_L0, -1);
      tmp_tril_00000= tril(L0, -1);
      g_tmp_diag_00000= call(@diag, g_L0);
      tmp_diag_00000= diag(L0);
      g_tmp_exp_00000= g_tmp_diag_00000.* exp(tmp_diag_00000);
      tmp_exp_00000= exp(tmp_diag_00000);
      g_tmp_diag_00001= call(@diag, g_tmp_exp_00000);
      tmp_diag_00001= diag(tmp_exp_00000);
      g_L= g_tmp_tril_00000+ g_tmp_diag_00001;
      L= tmp_tril_00000+ tmp_diag_00001; 
      
      g_tmp_mus_00000= g_mus(: , k);
      tmp_mus_00000= mus(: , k);
      g_tmp_example_gmm_adi_00000= g_tmp_mus_00000+ g_zeros(size(x));
      tmp_example_gmm_adi_00000= tmp_mus_00000- x;
      g_mahal= g_L* tmp_example_gmm_adi_00000+ L* g_tmp_example_gmm_adi_00000;
      mahal= L* tmp_example_gmm_adi_00000; 
      g_tmp_alphas_00000= g_alphas(k);
      tmp_alphas_00000= alphas(k);
      g_tmp_diag_00002= call(@diag, g_L0);
      tmp_diag_00002= diag(L0);
      g_tmp_sum_00000= call(@sum, g_tmp_diag_00002);
      tmp_sum_00000= sum(tmp_diag_00002);
      g_tmp_example_gmm_adi_00001= g_mahal' * mahal+ mahal' * g_mahal;
      tmp_example_gmm_adi_00001= mahal' * mahal;
      g_tmp_example_gmm_adi_00002= 0.5* g_tmp_example_gmm_adi_00001;
      tmp_example_gmm_adi_00002= 0.5* tmp_example_gmm_adi_00001;
      g_lse(k)= g_tmp_alphas_00000+ g_tmp_sum_00000- g_tmp_example_gmm_adi_00002;
      lse(k)= tmp_alphas_00000+ tmp_sum_00000- tmp_example_gmm_adi_00002; 
   end
   g_tmp_exp_00001= g_lse.* exp(lse);
   tmp_exp_00001= exp(lse);
   g_tmp_sum_00001= call(@sum, g_tmp_exp_00001);
   tmp_sum_00001= sum(tmp_exp_00001);
   g_tmp_log_00000= g_tmp_sum_00001./ tmp_sum_00001;
   tmp_log_00000= log(tmp_sum_00001);
   g_tmp_exp_00002= g_alphas.* exp(alphas);
   tmp_exp_00002= exp(alphas);
   g_tmp_sum_00002= call(@sum, g_tmp_exp_00002);
   tmp_sum_00002= sum(tmp_exp_00002);
   g_tmp_log_00001= g_tmp_sum_00002./ tmp_sum_00002;
   tmp_log_00001= log(tmp_sum_00002);
   g_nll= g_tmp_log_00000- g_tmp_log_00001;
   nll= tmp_log_00000- tmp_log_00001; 
   
end

