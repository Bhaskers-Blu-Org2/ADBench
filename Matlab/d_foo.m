% Generated by ADiMat 0.6.0-4975
% © 2001-2008 Andre Vehreschild <vehreschild@sc.rwth-aachen.de>
% © 2009-2015 Johannes Willkomm <johannes@johannes-willkomm.de>
% TU Darmstadt, 64289 Darmstadt, Germany
% Visit us on the web at http://www.adimat.de/
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%                             DISCLAIMER
% 
% ADiMat was prepared as part of an employment at the Institute for Scientific Computing,
% RWTH Aachen University, Germany and at the Institute for Scientific Computing,
% TU Darmstadt, Germany and is provided AS IS. 
% NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL REPUBLIC OF GERMANY
% NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY, NOT THE TU DARMSTADT,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY, EXPRESS OR IMPLIED,
% OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS,
% OR USEFULNESS OF ANY INFORMATION OR PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE
% WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS.
%
% Parameters:
%  - dependents=z
%  - independents=x
%  - inputEncoding=ISO-8859-1
%
% Functions in this file: d_foo
%

function [d_z z] = d_foo(k, d_x, x)
   d_y = adimat_opdiff_div(adimat_opdiff_subsref(d_x, struct('type', '()', 'subs', {{1 : 2}})), x(1 : 2), adimat_opdiff_subsref(d_x, struct('type', '()', 'subs', {{3}})), x(3));
   y = x(1 : 2) / x(3);
   d_tmpca1 = adimat_opdiff_epow_right(d_y, y, 2);
   tmpca1 = y .^ 2;
   d_rsq = adimat_diff_sum1(d_tmpca1, tmpca1);
   rsq = sum(tmpca1);
   d_tmpca4 = adimat_opdiff_mult_left(k(2), d_rsq, rsq);
   tmpca4 = k(2) * rsq;
   d_tmpca3 = adimat_opdiff_mult(d_tmpca4, tmpca4, d_rsq, rsq);
   tmpca3 = tmpca4 * rsq;
   d_tmpca2 = adimat_opdiff_mult_left(k(1), d_rsq, rsq);
   tmpca2 = k(1) * rsq;
   d_tmpca1 = adimat_opdiff_sum(d_tmpca2, d_tmpca3, d_zeros(1));
   tmpca1 = 1 + tmpca2 + tmpca3;
   d_z = adimat_opdiff_mult(d_y, y, d_tmpca1, tmpca1);
   z = y * tmpca1;
end
% function y = rodri(r,X)
% 
% 
% theta = sqrt(sum(r.^2));
% w = r/theta;
% tmp = (1-cos(theta))*(w'*X);
% w_cross_X = [w(2)*X(3) - w(3)*X(2);
%              w(3)*X(1) - w(1)*X(3);
%              w(1)*X(2) - w(2)*X(1)];
% y = cos(theta)*X + w_cross_X*sin(theta)+tmp*w;
% 
% end
