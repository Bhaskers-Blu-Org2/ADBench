% Generated by ADiMat 0.6.0-4975
% © 2001-2008 Andre Vehreschild <vehreschild@sc.rwth-aachen.de>
% © 2009-2015 Johannes Willkomm <johannes@johannes-willkomm.de>
% TU Darmstadt, 64289 Darmstadt, Germany
% Visit us on the web at http://www.adimat.de/
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%                             DISCLAIMER
% 
% ADiMat was prepared as part of an employment at the Institute for Scientific Computing,
% RWTH Aachen University, Germany and at the Institute for Scientific Computing,
% TU Darmstadt, Germany and is provided AS IS. 
% NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL REPUBLIC OF GERMANY
% NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY, NOT THE TU DARMSTADT,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY, EXPRESS OR IMPLIED,
% OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS,
% OR USEFULNESS OF ANY INFORMATION OR PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE
% WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS.
%
% Parameters:
%  - dependents=err
%  - independents=alphas, means, inv_cov_factors
%  - inputEncoding=ISO-8859-1
%
% Functions in this file: d_gmm_objective, d_log_wishart_prior,
%  log_wishart_prior, log_gamma_distrib, d_logsumexp_repmat
%

function [d_err err] = d_gmm_objective(d_alphas, alphas, d_means, means, d_inv_cov_factors, inv_cov_factors, x, hparams)
% GMM_OBJECTIVE  Evaluate GMM negative log likelihood for one point
%             ALPHAS 
%                1 x k vector of logs of mixture weights (unnormalized), so
%                weights = exp(log_alphas)/sum(exp(log_alphas))
%             MEANS
%                d x k matrix of component means
%             INV_COV_FACTORS 
%                (d*(d+1)/2) x k matrix, parametrizing 
%                lower triangular square roots of inverse covariances
%                log of diagonal is first d params
%             X 
%               are data points (d x n vector)
%             HPARAMS
%                [gamma, m] wishart distribution parameters
%         Output ERR is the sum of errors over all points
%      To generate params given covariance C:
%           L = inv(chol(C,'lower'));
%           inv_cov_factor = [log(diag(L)); L(au_tril_indices(d,-1))]
   Lparams = [];
   d_Lparams = d_zeros(Lparams);
   logLdiag = [];
   d_logLdiag = d_zeros(logLdiag);
   L = [];
   d_L = d_zeros(L);
   mahal = [];
   d_mahal = d_zeros(mahal);
   d = size(x, 1);
   k = size(alphas, 2);
   n = size(x, 2);
   lower_triangle_indices = tril(ones(d, d), -1) ~= 0;
   lse = zeros(k, n, 'like', alphas);
   d_lse = d_zeros(lse);
   for ik=1 : k
      d_Lparams = adimat_opdiff_subsref(d_inv_cov_factors, struct('type', '()', 'subs', {{':' ik}}));
      Lparams = inv_cov_factors(:, ik);
      d_logLdiag = adimat_opdiff_subsref(d_Lparams, struct('type', '()', 'subs', {{1 : d}}));
      logLdiag = Lparams(1 : d);
      [d_tmpca1 tmpca1] = adimat_diff_exp(d_logLdiag, logLdiag);
      [d_L L] = adimat_diff_diag(d_tmpca1, tmpca1);
      tmpda1 = d + 1;
      d_L = adimat_opdiff_subsasgn(d_L, struct('type', {'()'}, 'subs', {{lower_triangle_indices}}), adimat_opdiff_subsref(d_Lparams, struct('type', '()', 'subs', {{tmpda1 : adimat_end(Lparams, 1, 1)}})));
      L(lower_triangle_indices) = Lparams(tmpda1 : end);
      d_tmpca2 = adimat_diff_repmat2(adimat_opdiff_subsref(d_means, struct('type', '()', 'subs', {{':' ik}})), means(:, ik), 1, n);
      tmpca2 = repmat(means(:, ik), 1, n);
      d_tmpca1 = adimat_opdiff_sum(-d_tmpca2, d_zeros(x));
      tmpca1 = x - tmpca2;
      d_mahal = adimat_opdiff_mult(d_L, L, d_tmpca1, tmpca1);
      mahal = L * tmpca1;
      d_tmpca4 = adimat_opdiff_epow_right(d_mahal, mahal, 2);
      tmpca4 = mahal .^ 2;
      d_tmpca3 = adimat_diff_sum2(d_tmpca4, tmpca4, 1);
      tmpca3 = sum(tmpca4, 1);
      d_tmpca2 = adimat_opdiff_mult_left(0.5, d_tmpca3, tmpca3);
      tmpca2 = 0.5 * tmpca3;
      d_tmpca1 = adimat_diff_sum1(d_logLdiag, logLdiag);
      tmpca1 = sum(logLdiag);
      d_lse = adimat_opdiff_subsasgn(d_lse, struct('type', {'()'}, 'subs', {{ik ':'}}), adimat_opdiff_sum(adimat_opdiff_subsref(d_alphas, struct('type', '()', 'subs', {{ik}})), d_tmpca1, -d_tmpca2));
      lse(ik, :) = alphas(ik) + tmpca1 - tmpca2;
   end
   constant = 1 / sqrt(2 * pi)^d;
   [d_tmpca6 tmpca6] = d_logsumexp_repmat(d_alphas, alphas);
   d_tmpca5 = adimat_opdiff_mult_left(n, d_tmpca6, tmpca6);
   tmpca5 = n * tmpca6;
   [d_tmpca4 tmpca4] = d_logsumexp_repmat(d_lse, lse);
   d_tmpca3 = adimat_diff_sum1(d_tmpca4, tmpca4);
   tmpca3 = sum(tmpca4);
   tmpda2 = log(constant);
   tmpda1 = n * tmpda2;
   d_err = adimat_opdiff_sum(d_tmpca3, -d_tmpca5, d_zeros(tmpda1));
   err = tmpda1 + tmpca3 - tmpca5;
   [d_tmpca1 tmpca1] = d_log_wishart_prior(hparams, d, d_inv_cov_factors, inv_cov_factors);
   d_err = adimat_opdiff_sum(d_err, d_tmpca1);
   err = err + tmpca1;
end

function [d_out out] = d_log_wishart_prior(hparams, p, d_inv_cov_factors, inv_cov_factors)
% LOG_WISHART_PRIOR  
%               HPARAMS = [gamma m]
%               P data dimension
%             INV_COV_FACTORS
%                (d*(d+1)/2) x k matrix, parametrizing 
%                lower triangular square roots of inverse covariances
%                log of diagonal is first d params
   gamma = hparams(1);
   m = hparams(2);
   n = p + m + 1;
   tmpda9 = p + 1;
   d_tmpca8 = adimat_opdiff_epow_right(adimat_opdiff_subsref(d_inv_cov_factors, struct('type', '()', 'subs', {{tmpda9 : adimat_end(inv_cov_factors, 1, 2) ':'}})), inv_cov_factors(tmpda9 : end, :), 2);
   tmpca8 = inv_cov_factors(tmpda9 : end, :) .^ 2;
   d_tmpca7 = adimat_diff_sum2(d_tmpca8, tmpca8, 1);
   tmpca7 = sum(tmpca8, 1);
   [d_tmpca6 tmpca6] = adimat_diff_exp(adimat_opdiff_subsref(d_inv_cov_factors, struct('type', '()', 'subs', {{1 : p ':'}})), inv_cov_factors(1 : p, :));
   d_tmpca5 = adimat_opdiff_epow_right(d_tmpca6, tmpca6, 2);
   tmpca5 = tmpca6 .^ 2;
   d_tmpca4 = adimat_diff_sum2(d_tmpca5, tmpca5, 1);
   tmpca4 = sum(tmpca5, 1);
   d_tmpca3 = adimat_opdiff_sum(d_tmpca4, d_tmpca7);
   tmpca3 = tmpca4 + tmpca7;
   tmpda2 = gamma ^ 2;
   tmpda1 = 0.5 * tmpda2;
   d_term1 = adimat_opdiff_mult_left(tmpda1, d_tmpca3, tmpca3);
   term1 = tmpda1 * tmpca3;
   d_tmpca1 = adimat_diff_sum2(adimat_opdiff_subsref(d_inv_cov_factors, struct('type', '()', 'subs', {{1 : p ':'}})), inv_cov_factors(1 : p, :), 1);
   tmpca1 = sum(inv_cov_factors(1 : p, :), 1);
   d_term2 = adimat_opdiff_mult_left(m, d_tmpca1, tmpca1);
   term2 = m * tmpca1;
   C = n*p*(log(gamma) - 0.5*log(2)) - log_gamma_distrib(0.5 * n, p);
   d_tmpca1 = adimat_opdiff_sum(d_term1, -d_term2, d_zeros(-C));
   tmpca1 = term1 - term2 - C;
   d_out = adimat_diff_sum1(d_tmpca1, tmpca1);
   out = sum(tmpca1);
end

function out = log_wishart_prior(hparams, p, inv_cov_factors)
% LOG_WISHART_PRIOR  
%               HPARAMS = [gamma m]
%               P data dimension
%             INV_COV_FACTORS
%                (d*(d+1)/2) x k matrix, parametrizing 
%                lower triangular square roots of inverse covariances
%                log of diagonal is first d params
   gamma = hparams(1);
   m = hparams(2);
   n = p + m + 1;
   tmpda9 = p + 1;
   tmpca8 = inv_cov_factors(tmpda9 : end, :) .^ 2;
   tmpca7 = sum(tmpca8, 1);
   tmpca6 = exp(inv_cov_factors(1 : p, :));
   tmpca5 = tmpca6 .^ 2;
   tmpca4 = sum(tmpca5, 1);
   tmpca3 = tmpca4 + tmpca7;
   tmpda2 = gamma ^ 2;
   tmpda1 = 0.5 * tmpda2;
   term1 = tmpda1 * tmpca3;
   tmpca1 = sum(inv_cov_factors(1 : p, :), 1);
   term2 = m * tmpca1;
   C = n*p*(log(gamma) - 0.5*log(2)) - log_gamma_distrib(0.5 * n, p);
   tmpca1 = term1 - term2 - C;
   out = sum(tmpca1);
end

function out = log_gamma_distrib(a, p)
   out = log(pi ^ (0.25 * p * (p - 1)));
   for j=1 : p
      out = out + gammaln(a + 0.5*(1 - j));
   end
end

function [d_out out] = d_logsumexp_repmat(d_x, x)
% LOGSUMEXP  Compute log(sum(exp(x))) stably.
%               X is k x n
%               OUT is 1 x n
   [d_mx mx] = adimat_diff_max1(d_x, x);
   tmpda3 = size(x, 1);
   d_tmpca2 = adimat_diff_repmat2(d_mx, mx, tmpda3, 1);
   tmpca2 = repmat(mx, tmpda3, 1);
   d_tmpca1 = adimat_opdiff_sum(d_x, -d_tmpca2);
   tmpca1 = x - tmpca2;
   [d_emx emx] = adimat_diff_exp(d_tmpca1, tmpca1);
   d_semx = adimat_diff_sum1(d_emx, emx);
   semx = sum(emx);
   [d_tmpca1 tmpca1] = adimat_diff_log(d_semx, semx);
   d_out = adimat_opdiff_sum(d_tmpca1, d_mx);
   out = tmpca1 + mx;
end
