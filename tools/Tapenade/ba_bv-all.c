/*        Generated by TAPENADE     (INRIA, Tropics team)
Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
*/
#include "ba_bv.h"
#include <stdlib.h>
#include <math.h>
#include <float.h>
/*  Hint: NB_DIRS_REPROJ_BV should be the maximum number of differentiation directions
*/

/*
Differentiation of sqsum in reverse (adjoint) mode:
gradient     of useful results: *x sqsum
with respect to varying inputs: *x
Plus diff mem management of: x:in
*/
void sqsum_bv(int n,
  double *x,
  double(*xb)[NBDirsMaxReproj_BV],
  double sqsumb[NBDirsMaxReproj_BV],
  int nbdirs)
{
  double res;
  double resb[NBDirsMaxReproj_BV];
  int nd;
  double sqsum;
  for (nd = 0; nd < nbdirs; ++nd)
    resb[nd] = sqsumb[nd];
  for (int i = n - 1; i > -1; --i)
    for (nd = 0; nd < nbdirs; ++nd)
      xb[i][nd] = xb[i][nd] + 2 * x[i] * resb[nd];
}

/*
Differentiation of cross in reverse (adjoint) mode:
gradient     of useful results: *out *a *b
with respect to varying inputs: *a *b
Plus diff mem management of: out:in a:in b:in
*/
void cross_bv(
  double *a,
  double(*ab)[NBDirsMaxReproj_BV],
  double *b,
  double(*bb)[NBDirsMaxReproj_BV],
  double *out,
  double(*outb)[NBDirsMaxReproj_BV],
  int nbdirs)
{
  int nd;
  for (nd = 0; nd < nbdirs; ++nd)
  {
    ab[0][nd] = ab[0][nd] + b[1] * outb[2][nd];
    bb[1][nd] = bb[1][nd] + a[0] * outb[2][nd];
    ab[1][nd] = ab[1][nd] - b[0] * outb[2][nd];
    bb[0][nd] = bb[0][nd] - a[1] * outb[2][nd];
    outb[2][nd] = 0.0;
    ab[2][nd] = ab[2][nd] + b[0] * outb[1][nd];
    bb[0][nd] = bb[0][nd] + a[2] * outb[1][nd];
    ab[0][nd] = ab[0][nd] - b[2] * outb[1][nd];
    bb[2][nd] = bb[2][nd] - a[0] * outb[1][nd];
    outb[1][nd] = 0.0;
    ab[1][nd] = ab[1][nd] + b[2] * outb[0][nd];
    bb[2][nd] = bb[2][nd] + a[1] * outb[0][nd];
    ab[2][nd] = ab[2][nd] - b[1] * outb[0][nd];
    bb[1][nd] = bb[1][nd] - a[2] * outb[0][nd];
    outb[0][nd] = 0.0;
  }
}

/*
Differentiation of rodrigues_rotate_point in reverse (adjoint) mode:
gradient     of useful results: *rot *rotatedPt
with respect to varying inputs: *rot *pt
Plus diff mem management of: rot:in rotatedPt:in pt:in
*/
void rodrigues_rotate_point_bv(
  double *rot,
  double(*rotb)[NBDirsMaxReproj_BV],
  double *pt,
  double(*ptb)[NBDirsMaxReproj_BV],
  double *rotatedPt,
  double(*rotatedPtb)[NBDirsMaxReproj_BV],
  int nbdirs)
{
  int i;
  double sqtheta, theta, costheta, sintheta, theta_inverse, w[3], cross_[3], tmp;
  double sqthetab[NBDirsMaxReproj_BV], thetab[NBDirsMaxReproj_BV], costhetab[NBDirsMaxReproj_BV],
    sinthetab[NBDirsMaxReproj_BV], theta_inverseb[NBDirsMaxReproj_BV], wb[3][NBDirsMaxReproj_BV],
    cross_b[3][NBDirsMaxReproj_BV], tmpb[NBDirsMaxReproj_BV];
  int nd;
  double tempb[NBDirsMaxReproj_BV];
  int ii1;
  sqtheta = rot[0] * rot[0] + rot[1] * rot[1] + rot[2] * rot[2]; // sqsum is buggy for no reason with tapenade
  if (sqtheta != 0.) {
    theta = sqrt(sqtheta);
    costheta = cos(theta);
    sintheta = sin(theta);
    theta_inverse = 1.0 / theta;
    for (i = 0; i < 3; ++i)
      w[i] = rot[i] * theta_inverse;
    cross(w, pt, cross_);
    tmp = (w[0] * pt[0] + w[1] * pt[1] + w[2] * pt[2])*(1. - costheta);
    for (nd = 0; nd < nbdirs; ++nd) {
      for (i = 0; i < 3; i++)
        ptb[i][nd] = 0.0;
      for (ii1 = 0; ii1 < 3; ++ii1)
        wb[ii1][nd] = 0.0;
      for (ii1 = 0; ii1 < 3; ++ii1)
        cross_b[ii1][nd] = 0.0;
      costhetab[nd] = 0.0;
      tmpb[nd] = 0.0;
      sinthetab[nd] = 0.0;
    }
    for (i = 2; i > -1; --i)
      for (nd = 0; nd < nbdirs; ++nd) {
        ptb[i][nd] = ptb[i][nd] + costheta*rotatedPtb[i][nd];
        costhetab[nd] = costhetab[nd] + pt[i] * rotatedPtb[i][nd];
        cross_b[i][nd] = cross_b[i][nd] + sintheta*rotatedPtb[i][nd];
        sinthetab[nd] = sinthetab[nd] + cross_[i] * rotatedPtb[i][nd];
        wb[i][nd] = wb[i][nd] + tmp*rotatedPtb[i][nd];
        tmpb[nd] = tmpb[nd] + w[i] * rotatedPtb[i][nd];
        rotatedPtb[i][nd] = 0.0;
      }
    for (nd = 0; nd < nbdirs; ++nd) {
      tempb[nd] = (1. - costheta)*tmpb[nd];
      wb[0][nd] = wb[0][nd] + pt[0] * tempb[nd];
      ptb[0][nd] = ptb[0][nd] + w[0] * tempb[nd];
      wb[1][nd] = wb[1][nd] + pt[1] * tempb[nd];
      ptb[1][nd] = ptb[1][nd] + w[1] * tempb[nd];
      wb[2][nd] = wb[2][nd] + pt[2] * tempb[nd];
      ptb[2][nd] = ptb[2][nd] + w[2] * tempb[nd];
      costhetab[nd] = costhetab[nd] - (w[0] * pt[0] + w[1] * pt[1] + w[2] * pt[2])
        *tmpb[nd];
    }
    cross_bv(w, wb, pt, ptb, cross_, cross_b, nbdirs);
    for (nd = 0; nd < nbdirs; ++nd)
      theta_inverseb[nd] = 0.0;
    for (i = 2; i > -1; --i)
      for (nd = 0; nd < nbdirs; ++nd) {
        rotb[i][nd] = rotb[i][nd] + theta_inverse*wb[i][nd];
        theta_inverseb[nd] = theta_inverseb[nd] + rot[i] * wb[i][nd];
        wb[i][nd] = 0.0;
      }
    for (nd = 0; nd < nbdirs; ++nd) {
      thetab[nd] = cos(theta)*sinthetab[nd] - sin(theta)*costhetab[nd] -
        theta_inverseb[nd] / (theta*theta);
      if (sqtheta == 0.0)
        sqthetab[nd] = 0.0;
      else
        sqthetab[nd] = thetab[nd] / (2.0*sqrt(sqtheta));
    }
  }
  else {
    for (nd = 0; nd < nbdirs; ++nd) {
      for (i = 0; i < 3; i++)
        ptb[i][nd] = 0.0;
      for (ii1 = 0; ii1 < 3; ++ii1)
        cross_b[ii1][nd] = 0.0;
    }
    for (i = 2; i > -1; --i)
      for (nd = 0; nd < nbdirs; ++nd) {
        ptb[i][nd] = ptb[i][nd] + rotatedPtb[i][nd];
        cross_b[i][nd] = cross_b[i][nd] + rotatedPtb[i][nd];
        rotatedPtb[i][nd] = 0.0;
      }
    cross_bv(rot, rotb, pt, ptb, cross_, cross_b, nbdirs);
    for (nd = 0; nd < nbdirs; ++nd)
      sqthetab[nd] = 0.0;
  }
  sqsum_bv(3, rot, rotb, sqthetab, nbdirs);
}

/*
Differentiation of radial_distort in reverse (adjoint) mode:
gradient     of useful results: *rad_params *proj
with respect to varying inputs: *rad_params *proj
Plus diff mem management of: rad_params:in proj:in
*/
void radial_distort_bv(
  double *rad_params,
  double(*rad_paramsb)[NBDirsMaxReproj_BV],
  double *proj,
  double(*projb)[NBDirsMaxReproj_BV],
  int nbdirs)
{
  double rsq, L;
  double rsqb[NB_DIRS_REPROJ_BV], Lb[NB_DIRS_REPROJ_BV];
  int nd;
  rsq = proj[0] * proj[0] + proj[1] * proj[1]; // sqsum is buggy for no reason with tapenade
  L = 1 + rad_params[0] * rsq + rad_params[1] * rsq*rsq;
  pushreal8(proj[0]);
  pushreal8(proj[1]);
  proj[0] = proj[0] * L;
  for (nd = 0; nd < nbdirs; ++nd) {
    Lb[nd] = proj[1] * projb[1][nd];
    projb[1][nd] = L*projb[1][nd];
  }
  popreal8(&proj[1]);
  popreal8(&proj[0]);
  for (nd = 0; nd < nbdirs; ++nd) {
    Lb[nd] = Lb[nd] + proj[0] * projb[0][nd];
    projb[0][nd] = L*projb[0][nd];
    rad_paramsb[0][nd] = rad_paramsb[0][nd] + rsq*Lb[nd];
    rsqb[nd] = (rad_params[1] * 2 * rsq + rad_params[0])*Lb[nd];
    rad_paramsb[1][nd] = rad_paramsb[1][nd] + rsq*rsq*Lb[nd];
  }
  sqsum_bv(2, proj, projb, rsqb, nbdirs);
}

/*
Differentiation of project in reverse (adjoint) mode:
gradient     of useful results: *cam *X *proj
with respect to varying inputs: *cam *X
Plus diff mem management of: cam:in X:in proj:in-out
*/
void project_bv(
  double *cam,
  double(*camb)[NBDirsMaxReproj_BV],
  double *X,
  double(*Xb)[NBDirsMaxReproj_BV],
  double *proj,
  double(*projb)[NBDirsMaxReproj_BV],
  int nbdirs)
{
  int i;
  double *C;
  double(*Cb)[NB_DIRS_REPROJ_BV];
  double Xo[3], Xcam[3];
  double Xob[3][NBDirsMaxReproj_BV], Xcamb[3][NBDirsMaxReproj_BV];
  int nd;
  double tempb0[NBDirsMaxReproj_BV];
  double tempb[NBDirsMaxReproj_BV];
  int ii1;
  Cb = &camb[3];
  C = &cam[3];
  for (i = 0; i < 3; ++i)
    Xo[i] = X[i] - C[i];
  rodrigues_rotate_point(&cam[0], Xo, Xcam);
  proj[0] = Xcam[0] / Xcam[2];
  proj[1] = Xcam[1] / Xcam[2];
  pushreal8(proj[0]);
  pushreal8(proj[1]);
  radial_distort(&cam[9], proj);
  for (i = 0; i < 2; ++i) {
    pushreal8(proj[i]);
    proj[i] = proj[i] * cam[6] + cam[7 + i];
  }
  for (i = 1; i > -1; --i) {
    popreal8(&proj[i]);
    for (nd = 0; nd < nbdirs; ++nd) {
      camb[6][nd] = camb[6][nd] + proj[i] * projb[i][nd];
      camb[7 + i][nd] = camb[7 + i][nd] + projb[i][nd];
      projb[i][nd] = cam[6] * projb[i][nd];
    }
  }
  popreal8(&proj[1]);
  popreal8(&proj[0]);
  radial_distort_bv(&cam[9], &camb[9], proj, projb, nbdirs);
  for (nd = 0; nd < nbdirs; ++nd) {
    for (ii1 = 0; ii1 < 3; ++ii1)
      Xcamb[ii1][nd] = 0.0;
    tempb[nd] = projb[1][nd] / Xcam[2];
    Xcamb[1][nd] = Xcamb[1][nd] + tempb[nd];
    Xcamb[2][nd] = Xcamb[2][nd] - Xcam[1] * tempb[nd] / Xcam[2];
    projb[1][nd] = 0.0;
    tempb0[nd] = projb[0][nd] / Xcam[2];
    Xcamb[0][nd] = Xcamb[0][nd] + tempb0[nd];
    Xcamb[2][nd] = Xcamb[2][nd] - Xcam[0] * tempb0[nd] / Xcam[2];
  }
  rodrigues_rotate_point_bv(&cam[0], &camb[0], Xo, Xob, Xcam, Xcamb, nbdirs);
  for (i = 2; i > -1; --i)
    for (nd = 0; nd < nbdirs; ++nd) {
      Xb[i][nd] = Xb[i][nd] + Xob[i][nd];
      Cb[i][nd] = Cb[i][nd] - Xob[i][nd];
      Xob[i][nd] = 0.0;
    }
}

/*
Differentiation of computeReprojError in reverse (adjoint) mode:
gradient     of useful results: *err
with respect to varying inputs: *err *w *cam *X
RW status of diff variables: *err:in-out *w:out *cam:out *X:out
Plus diff mem management of: err:in w:in cam:in X:in
*/
void computeReprojError_bv(
  double *cam, 
  double(*camb)[NBDirsMaxReproj_BV], 
  double *X,
  double(*Xb)[NBDirsMaxReproj_BV], 
  double *w, 
  double(*wb)[NBDirsMaxReproj_BV], 
  double feat_x, double feat_y, 
  double *err, 
  double(*errb)[NBDirsMaxReproj_BV], 
  int nbdirs) 
{
  double proj[2];
  double projb[2][NBDirsMaxReproj_BV];
  int nd;
  int ii1;
  pushreal8(proj[0]);
  pushreal8(proj[1]);
  project(cam, X, proj);

  err[0] = (*w)*(proj[0] - feat_x);
  err[1] = (*w)*(proj[1] - feat_y);
  
  // This term is here so that tapenade correctly 
  // recognizes inputs to be the inputs
  for (nd = 0; nd < nbdirs; ++nd) {
    for (ii1 = 0; ii1 < 2; ++ii1)
      projb[ii1][nd] = 0.0;
    (*wb)[nd] = (proj[1] - feat_y)*errb[1][nd];
    projb[1][nd] = projb[1][nd] + (*w)*errb[1][nd];
    errb[1][nd] = 0.0;
    (*wb)[nd] = (*wb)[nd] + (proj[0] - feat_x)*errb[0][nd];
    projb[0][nd] = projb[0][nd] + (*w)*errb[0][nd];
    errb[0][nd] = 0.0;
  }
  popreal8(&proj[1]);
  popreal8(&proj[0]);
  project_bv(cam, camb, X, Xb, proj, projb, nbdirs);
}

/*
Differentiation of computeZachWeightError in reverse (adjoint) mode:
gradient     of useful results: *err
with respect to varying inputs: *err *w
RW status of diff variables: *err:in-zero *w:out
Plus diff mem management of: err:in w:in
*/
void computeZachWeightError_b(double *w, double *wb, double *err, double *errb
  ) {
  *wb = -(2 * (*w)*(*errb));
  *errb = 0.0;
}