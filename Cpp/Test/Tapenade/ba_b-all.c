/*        Generated by TAPENADE     (INRIA, Tropics team)
    Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
*/
#include <stdlib.h>
#include <math.h>
#include <float.h>

/*
  Differentiation of rodrigues_rot in reverse (adjoint) mode:
   gradient     of useful results: *rot *R
   with respect to varying inputs: *rot *R
   Plus diff mem management of: rot:in R:in
*/
// rot 3 rotation parameters
// R 3*3 rotation matrix (column major)
// easy to understand calculation in matlab:
//	theta = sqrt(sum(w. ^ 2));
//	n = w / theta;
//	n_x = au_cross_matrix(n);
//	R = eye(3) + n_x*sin(theta) + n_x*n_x*(1 - cos(theta));
void rodrigues_rot_b(double *rot, double *rotb, double *R, double *Rb) {
    double w1, w2, w3, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14
    , t15, t17, t23, t32;
    double w1b, w2b, w3b, t2b, t3b, t4b, t5b, t6b, t7b, t8b, t9b, t10b, t11b, 
    t12b, t13b, t14b, t15b, t17b, t23b, t32b;
    double tempb9;
    double tempb8;
    double tempb7;
    double tempb6;
    double tempb5;
    double tempb4;
    double tempb3;
    double tempb2;
    double tempb1;
    double tempb0;
    double tempb10;
    double tempb;
    w1 = rot[0];
    w2 = rot[1];
    w3 = rot[2];
    t2 = w2*w2;
    t3 = w1*w1;
    t4 = w3*w3;
    t5 = t2 + t3 + t4 + (double)2.22044604925031308085e-16L;
    t7 = sqrt(t5);
    t8 = cos(t7);
    t10 = sin(t7);
    t9 = t8 - 1.0;
    t11 = 1./t7;
    t6 = 1./t5;
    t12 = t4*t6;
    t14 = t3*t6;
    t15 = t2*t6;
    t17 = t12 + t15;
    t23 = t12 + t14;
    t32 = t14 + t15;
    // first row
    // second row
    // third row
    t9b = t32*Rb[2*3+2];
    t32b = t9*Rb[2*3+2];
    Rb[2*3 + 2] = 0.0;
    tempb = -(w2*w3*Rb[1*3+2]);
    tempb0 = -(t6*t9*Rb[1*3+2]);
    t10b = w1*t11*Rb[1*3+2];
    t11b = w1*t10*Rb[1*3+2];
    w1b = t10*t11*Rb[1*3+2];
    Rb[1*3 + 2] = 0.0;
    tempb1 = -(w1*w3*Rb[0*3+2]);
    tempb9 = -(t6*t9*Rb[0*3+2]);
    t13b = -Rb[0*3+2];
    Rb[0*3 + 2] = 0.0;
    w1b = w1b + w3*tempb9 - t10*t11*Rb[2*3+1];
    tempb5 = -(w2*w3*Rb[2*3+1]);
    tempb6 = -(t6*t9*Rb[2*3+1]);
    t10b = t10b - w1*t11*Rb[2*3+1];
    t11b = t11b - w1*t10*Rb[2*3+1];
    Rb[2*3 + 1] = 0.0;
    t9b = t9b + t6*tempb1 + t23*Rb[1*3+1] + t6*tempb5 + t6*tempb;
    t23b = t9*Rb[1*3+1];
    Rb[1*3 + 1] = 0.0;
    w3b = w1*tempb9 + t10*t11*Rb[0*3+1] + w2*tempb6 + w2*tempb0;
    tempb2 = -(w1*w2*Rb[0*3+1]);
    tempb8 = -(t6*t9*Rb[0*3+1]);
    t10b = t10b + w3*t11*Rb[0*3+1];
    t11b = t11b + w3*t10*Rb[0*3+1];
    Rb[0*3 + 1] = 0.0;
    tempb4 = -(w1*w3*Rb[2*3+0]);
    tempb10 = -(t6*t9*Rb[2*3+0]);
    t13b = t13b + Rb[2*3 + 0];
    Rb[2*3 + 0] = 0.0;
    w3b = w3b + w1*tempb10 - t10*t11*Rb[1*3+0];
    tempb3 = -(w1*w2*Rb[1*3+0]);
    tempb7 = -(t6*t9*Rb[1*3+0]);
    t10b = t10b + w2*t11*t13b - w3*t11*Rb[1*3+0];
    t11b = t11b + w2*t10*t13b - w3*t10*Rb[1*3+0];
    Rb[1*3 + 0] = 0.0;
    t9b = t9b + t6*tempb4 + t17*Rb[0*3+0] + t6*tempb3 + t6*tempb2;
    t17b = t9*Rb[0*3+0];
    Rb[0*3 + 0] = 0.0;
    t14b = t23b + t32b;
    t15b = t17b + t32b;
    t12b = t17b + t23b;
    t6b = t9*tempb1 + t9*tempb2 + t9*tempb3 + t3*t14b + t4*t12b + t2*t15b + t9
        *tempb4 + t9*tempb5 + t9*tempb;
    t8b = t9b;
    t7b = cos(t7)*t10b - sin(t7)*t8b - t11b/(t7*t7);
    if (t5 == 0.0)
        t5b = -(t6b/(t5*t5));
    else
        t5b = t7b/(2.0*sqrt(t5)) - t6b/(t5*t5);
    t2b = t5b + t6*t15b;
    w2b = w3*tempb6 + w1*tempb7 + 2*w2*t2b + t10*t11*t13b + w1*tempb8 + w3*
        tempb0;
    t3b = t5b + t6*t14b;
    w1b = w1b + w3*tempb10 + 2*w1*t3b + w2*tempb7 + w2*tempb8;
    t4b = t5b + t6*t12b;
    w3b = w3b + 2*w3*t4b;
    rotb[2] = rotb[2] + w3b;
    rotb[1] = rotb[1] + w2b;
    rotb[0] = rotb[0] + w1b;
}

/*
  Differentiation of radial_distort in reverse (adjoint) mode:
   gradient     of useful results: *rad_params *proj
   with respect to varying inputs: *rad_params *proj
   Plus diff mem management of: proj:in
*/
// rad_params 2 radial distortion parameters
// proj 2 projection to be distorted
void radial_distort_b(double *rad_params, double *rad_paramsb, double *proj, 
        double *projb) {
    double rsq = proj[0]*proj[0] + proj[1]*proj[1];
    double rsqb;
    double L = 1 + rad_params[0]*rsq + rad_params[1]*rsq*rsq;
    double Lb;
    pushreal8(proj[0]);
    proj[0] = proj[0]*L;
    Lb = proj[1]*projb[1];
    projb[1] = L*projb[1];
    popreal8(&proj[0]);
    Lb = Lb + proj[0]*projb[0];
    projb[0] = L*projb[0];
    rad_paramsb[0] = rad_paramsb[0] + rsq*Lb;
    rsqb = (rad_params[1]*2*rsq+rad_params[0])*Lb;
    rad_paramsb[1] = rad_paramsb[1] + rsq*rsq*Lb;
    projb[0] = projb[0] + 2*proj[0]*rsqb;
    projb[1] = projb[1] + 2*proj[1]*rsqb;
}

/*
  Differentiation of project in reverse (adjoint) mode:
   gradient     of useful results: *cam *R *X *proj
   with respect to varying inputs: *cam *R *X *proj
   Plus diff mem management of: cam:in R:in X:in proj:in-out
*/
// cam 11 cameras in format [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]
//            r1, r2, r3 are angle - axis rotation parameters(Rodrigues)
//			  [C1 C2 C3]' is the camera center
//            f is the focal length in pixels
//			  [u0 v0]' is the principal point
//            k1, k2 are radial distortion parameters
// R 3*3 column major rotation matrix
// X 3 point
// proj 2 projection
// projection: 
// Xcam = R * (X - C)
// distorted = radial_distort(projective2euclidean(Xcam), radial_parameters)
// proj = distorted * f + principal_point
// err = sqsum(proj - measurement)
void project_b(double *cam, double *camb, double *R, double *Rb, double *X, 
        double *Xb, double *proj, double *projb) {
    int i, k, Ridx;
    double *C;
    double *Cb;
    double Xo[3], Xcam[3];
    double Xob[3], Xcamb[3];
    double tempb0;
    double tempb;
    int ii1;
    Cb = &camb[3];
    C = &cam[3];
    Xo[0] = X[0] - C[0];
    Xo[1] = X[1] - C[1];
    Xo[2] = X[2] - C[2];
    Xcam[0] = 0.;
    Xcam[1] = 0.;
    Xcam[2] = 0.;
    Ridx = 0;
    for (i = 0; i < 3; ++i)
        for (k = 0; k < 3; ++k) {
            Xcam[k] = Xcam[k] + R[Ridx]*Xo[i];
            pushinteger4(Ridx);
            Ridx = Ridx + 1;
        }
    pushreal8(proj[0]);
    proj[0] = Xcam[0]/Xcam[2];
    pushreal8(proj[1]);
    proj[1] = Xcam[1]/Xcam[2];
    pushreal8(*proj);
    radial_distort(&cam[9], proj);
    pushreal8(proj[0]);
    proj[0] = proj[0]*cam[6] + cam[7];
    camb[6] = camb[6] + proj[1]*projb[1];
    camb[8] = camb[8] + projb[1];
    projb[1] = cam[6]*projb[1];
    popreal8(&proj[0]);
    camb[6] = camb[6] + proj[0]*projb[0];
    camb[7] = camb[7] + projb[0];
    projb[0] = cam[6]*projb[0];
    popreal8(proj);
    radial_distort_b(&cam[9], &camb[9], proj, projb);
    for (ii1 = 0; ii1 < 3; ++ii1)
        Xcamb[ii1] = 0.0;
    popreal8(&proj[1]);
    tempb = projb[1]/Xcam[2];
    Xcamb[1] = Xcamb[1] + tempb;
    Xcamb[2] = Xcamb[2] - Xcam[1]*tempb/Xcam[2];
    projb[1] = 0.0;
    popreal8(&proj[0]);
    tempb0 = projb[0]/Xcam[2];
    Xcamb[0] = Xcamb[0] + tempb0;
    Xcamb[2] = Xcamb[2] - Xcam[0]*tempb0/Xcam[2];
    projb[0] = 0.0;
    for (ii1 = 0; ii1 < 3; ++ii1)
        Xob[ii1] = 0.0;
    for (i = 2; i > -1; --i)
        for (k = 2; k > -1; --k) {
            popinteger4(&Ridx);
            Rb[Ridx] = Rb[Ridx] + Xo[i]*Xcamb[k];
            Xob[i] = Xob[i] + R[Ridx]*Xcamb[k];
        }
    Xb[2] = Xb[2] + Xob[2];
    Cb[2] = Cb[2] - Xob[2];
    Xob[2] = 0.0;
    Xb[1] = Xb[1] + Xob[1];
    Cb[1] = Cb[1] - Xob[1];
    Xob[1] = 0.0;
    Xb[0] = Xb[0] + Xob[0];
    Cb[0] = Cb[0] - Xob[0];
}

/*
  Differentiation of ba in reverse (adjoint) mode:
   gradient     of useful results: *err
   with respect to varying inputs: *err *cams *X
   RW status of diff variables: *err:in-out *cams:out *X:out
   Plus diff mem management of: err:in cams:in X:in
*/
// n number of cameras
// m number of points
// p number of observations
// cams 11*n cameras in format [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]
//            r1, r2, r3 are angle - axis rotation parameters(Rodrigues)
//			  [C1 C2 C3]' is the camera center
//            f is the focal length in pixels
//			  [u0 v0]' is the principal point
//            k1, k2 are radial distortion parameters
// X 3*m points
// obs 2*p observations (pairs cameraIdx, pointIdx)
// feats 2*p features (x,y coordinates corresponding to observations)
// err p squared errors of observations
// projection: 
// Xcam = R * (X - C)
// distorted = radial_distort(projective2euclidean(Xcam), radial_parameters)
// proj = distorted * f + principal_point
// err = sqsum(proj - measurement)
void ba_b(int n, int m, int p, double *cams, double *camsb, double *X, double 
        *Xb, int *obs, double *feats, double *err, double *errb) {
	int i, camIdx, ptIdx;
    int nCamParams = 11;
    double *Rb = (double *)malloc(3*3*n*sizeof(double));
    double *R = (double *)malloc(3*3*n*sizeof(double));
    double *projb = (double *)malloc(2*sizeof(double));
    double *proj = (double *)malloc(2*sizeof(double));
    for (i = 0; i < n; ++i)
        rodrigues_rot(&cams[i*nCamParams], &R[i*3*3]);
	for (i = 0; i < p; ++i) {
		camIdx = obs[i * 2 + 0];
		ptIdx = obs[i * 2 + 1];
        pushreal8(*proj);
        project(&cams[camIdx*nCamParams], &R[camIdx*3*3], &X[ptIdx*3], proj);
        pushreal8(proj[0]);
        proj[0] = proj[0] - feats[i*2 + 0];
        pushreal8(proj[1]);
        proj[1] = proj[1] - feats[i*2 + 1];
        pushinteger4(ptIdx);
        pushinteger4(camIdx);
    }
	memset(projb, 0, 2 * sizeof(double));
	memset(Rb, 0, 3 * 3 * n*sizeof(double));
    for (i = p-1; i > -1; --i) {
        popinteger4(&camIdx);
        popinteger4(&ptIdx);
        projb[0] = projb[0] + 2*proj[0]*errb[i];
        projb[1] = projb[1] + 2*proj[1]*errb[i];
        errb[i] = 0.0;
        popreal8(&proj[1]);
        popreal8(&proj[0]);
        popreal8(proj);
        project_b(&cams[camIdx*nCamParams], &camsb[camIdx*nCamParams], &R[
                  camIdx*3*3], &Rb[camIdx*3*3], &X[ptIdx*3], &Xb[ptIdx*3], 
                  proj, projb);
    }
    for (i = n-1; i > -1; --i)
        rodrigues_rot_b(&cams[i*nCamParams], &camsb[i*nCamParams], &R[i*3*3], 
                        &Rb[i*3*3]);
    free(proj);
    free(projb);
    free(R);
    free(Rb);
}
