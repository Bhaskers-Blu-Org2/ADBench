/*        Generated by TAPENADE     (INRIA, Tropics team)
Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
*/
#include "ba.h"
#include "adStack.h"

#define NB_DIRS_REPROJ_BV 2

// rot 3 rotation parameters
// pt 3 point to be rotated
// rotatedPt 3 rotated point
// this is an efficient evaluation (part of
// the Ceres implementation)
// easy to understand calculation in matlab:
//	theta = sqrt(sum(w. ^ 2));
//	n = w / theta;
//	n_x = au_cross_matrix(n);
//	R = eye(3) + n_x*sin(theta) + n_x*n_x*(1 - cos(theta));
void rodrigues_rotate_point(double *rot, double *pt, double *rotatedPt);
void rodrigues_rotate_point_bv(double *rot, double(*rotb)[NB_DIRS_REPROJ_BV], double
  *pt, double(*ptb)[NB_DIRS_REPROJ_BV], double *rotatedPt, double(*rotatedPtb)[
    NB_DIRS_REPROJ_BV], int nbdirs);
// rad_params 2 radial distortion parameters
// proj 2 projection to be distorted
void radial_distort(double *rad_params, double *proj);
void radial_distort_bv(double *rad_params, double(*rad_paramsb)[NB_DIRS_REPROJ_BV],
  double *proj, double(*projb)[NB_DIRS_REPROJ_BV], int nbdirs);
// cam 11 cameras in format [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]
//            r1, r2, r3 are angle - axis rotation parameters(Rodrigues)
//			  [C1 C2 C3]' is the camera center
//            f is the focal length in pixels
//			  [u0 v0]' is the principal point
//            k1, k2 are radial distortion parameters
// X 3 point
// proj 2 projection
// projection: 
// Xcam = R * (X - C)
// distorted = radial_distort(projective2euclidean(Xcam), radial_parameters)
// proj = distorted * f + principal_point
// err = sqsum(proj - measurement)
void project(double *cam, double *X, double *proj);
void project_bv(double *cam, double(*camb)[NB_DIRS_REPROJ_BV], double *X, double(*Xb
  )[NB_DIRS_REPROJ_BV], double *proj, double(*projb)[NB_DIRS_REPROJ_BV], int nbdirs);
void computeReprojError(double *cam, double *X, double *w, double feat_x,
  double feat_y, double *err);
void computeReprojError_bv(double *cam, double(*camb)[NB_DIRS_REPROJ_BV], double *X,
  double(*Xb)[NB_DIRS_REPROJ_BV], double *w, double(*wb)[NB_DIRS_REPROJ_BV], double feat_x
  , double feat_y, double *err, double(*errb)[NB_DIRS_REPROJ_BV], int nbdirs);
// temporal prior
void computeFocalPriorError(double *cam1, double *cam2, double *cam3, double *
  err);
void computeFocalPriorError_b(double *cam1, double *cam1b, double *cam2,
  double *cam2b, double *cam3, double *cam3b, double *err, double *errb);
void computeZachWeightError(double *w, double *err);
void computeZachWeightError_b(double *w, double *wb, double *err, double *errb
  );
// n number of cameras
// m number of points
// p number of observations
// cams 11*n cameras in format [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]
//            r1, r2, r3 are angle - axis rotation parameters(Rodrigues)
//			  [C1 C2 C3]' is the camera center
//            f is the focal length in pixels
//			  [u0 v0]' is the principal point
//            k1, k2 are radial distortion parameters
// X 3*m points
// obs 2*p observations (pairs cameraIdx, pointIdx)
// feats 2*p features (x,y coordinates corresponding to observations)
// reproj_err 2*p errors of observations
// f_prior_err n-2 temporal prior on focals
// w_err p coputes like 1-w^2
// projection: 
// Xcam = R * (X - C)
// distorted = radial_distort(projective2euclidean(Xcam), radial_parameters)
// proj = distorted * f + principal_point
// err = sqsum(proj - measurement)
void ba_objective(int n, int m, int p, double *cams, double *X, double *w, int
  *obs, double *feats, double *reproj_err, double *f_prior_err, double *
  w_err);
