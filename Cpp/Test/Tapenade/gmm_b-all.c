/*        Generated by TAPENADE     (INRIA, Tropics team)
Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
*/
#include "gmm_b.h"
#include <math.h>
#include <stdlib.h>

/*
Differentiation of arr_max in reverse (adjoint) mode:
gradient     of useful results: *x arr_max
with respect to varying inputs: *x
Plus diff mem management of: x:in
*/
void arr_max_b(int n, double *x, double *xb, double arr_maxb) {
  double m;
  double mb;
  int i;
  int branch;
  double arr_max;
  m = x[0];
  for (i = 1; i < n; ++i)
    if (x[i] > m) {
      m = x[i];
      pushcontrol1b(1);
    }
    else
      pushcontrol1b(0);
  mb = arr_maxb;
  for (i = n - 1; i > 0; --i) {
    popcontrol1b(&branch);
    if (branch != 0) {
      xb[i] = xb[i] + mb;
      mb = 0.0;
    }
  }
  xb[0] = xb[0] + mb;
}

/*
Differentiation of logsumexp in reverse (adjoint) mode:
gradient     of useful results: *x logsumexp
with respect to varying inputs: *x
Plus diff mem management of: x:in
*/
double logsumexp_b(int n, double *x, double *xb, double logsumexpb) {
  int i;
  double mx, semx;
  double mxb, semxb;
  double logsumexp;
  double tempb;
  mx = arr_max(n, x);
  semx = 0.;
  for (i = 0; i < n; ++i)
    semx = semx + exp(x[i] - mx);
  semxb = logsumexpb / semx;
  mxb = logsumexpb;
  for (i = n - 1; i > -1; --i) {
    tempb = exp(x[i] - mx)*semxb;
    xb[i] = xb[i] + tempb;
    mxb = mxb - tempb;
  }
  arr_max_b(n, x, xb, mxb);
  return log(semx) + mx;
}

/*
Differentiation of log_wishart_prior in reverse (adjoint) mode:
gradient     of useful results: log_wishart_prior *icf
with respect to varying inputs: *icf
Plus diff mem management of: icf:in
*/
double log_wishart_prior_b(int p, int k, Wishart wishart, double *icf, double *
  icfb, double log_wishart_priorb) {
  int n, ik, i, icf_sz;
  double out, C, frobenius, sum_log_diag, tmp, tmp_term1;
  double outb, frobeniusb, sum_log_diagb, tmpb;
  float arg1;
  double result1;
  double log_wishart_prior;
  n = p + wishart.m + 1;
  C = n*p*(log(wishart.gamma) - 0.5*log(2)) - log_gamma_distrib(0.5*n, p);
  tmp = 0;
  icf_sz = p*(p + 1) / 2;
  for (ik = 0; ik < k; ++ik) {
    for (i = 0; i < p; ++i) {
      pushreal8(tmp);
      tmp = icf[icf_sz*ik + i];
      pushreal8(tmp);
      tmp = exp(tmp);
    }
    for (i = p; i < icf_sz; ++i)
      pushreal8(tmp);
  }
  out = 0.;
  outb = log_wishart_priorb;
  for (ik = k - 1; ik > -1; --ik) {
    tmp_term1 = wishart.gamma*wishart.gamma*0.5;
    frobenius = 0.;
    frobeniusb = tmp_term1*outb;
    sum_log_diag = 0.;
    sum_log_diagb = -(wishart.m*outb);
    for (i = icf_sz - 1; i > p - 1; --i) {
      tmp = icf[icf_sz*ik + i];
      frobenius = frobenius + tmp*tmp;
      tmpb = 2 * tmp*frobeniusb;
      popreal8(&tmp);
      icfb[icf_sz*ik + i] = icfb[icf_sz*ik + i] + tmpb;
    }
    for (i = p - 1; i > -1; --i) {
      tmpb = 2 * tmp*frobeniusb;
      popreal8(&tmp);
      sum_log_diag = sum_log_diag + tmp;
      tmp = exp(tmp);
      frobenius = frobenius + tmp*tmp;
      tmpb = sum_log_diagb + tmp*tmpb;
      popreal8(&tmp);
      icfb[icf_sz*ik + i] = icfb[icf_sz*ik + i] + tmpb;
    }
    out = out + tmp_term1*(frobenius)
      -wishart.m * sum_log_diag;
  }
  return out - k*C;
}

/*
Differentiation of gmm_objective in reverse (adjoint) mode:
gradient     of useful results: *err
with respect to varying inputs: *err *means *icf *alphas
RW status of diff variables: *err:in-zero *means:out *icf:out
*alphas:out
Plus diff mem management of: err:in means:in icf:in alphas:in
*/
void gmm_objective_b(int d, int k, int n, double *alphas, double *alphasb,
  double *means, double *meansb, double *icf, double *icfb, double *x,
  Wishart wishart, double *err, double *errb) {
  int ik, ix, id, i, j, icf_sz, icf_off, Lparamsidx;
  double *lse, *Ldiag, *xcentered, *mahal;
  double *lseb, *Ldiagb, *xcenteredb, *mahalb;
  double sumlog_Ldiag, sqsum_mahal, slse, lse_alphas, CONSTANT;
  double sumlog_Ldiagb, sqsum_mahalb, slseb, lse_alphasb, log_wish_prior_res;
  double arg1;
  double result1;
  double result1b;
  int adFrom;
  CONSTANT = -n*d*0.5*log(2 * PI);
  icf_sz = d*(d + 1) / 2;
  lseb = (double *)malloc(k*sizeof(double));
  lse = (double *)malloc(k*sizeof(double));
  Ldiagb = (double *)malloc(d*sizeof(double));
  Ldiag = (double *)malloc(d*sizeof(double));
  xcenteredb = (double *)malloc(d*sizeof(double));
  xcentered = (double *)malloc(d*sizeof(double));
  mahalb = (double *)malloc(d*sizeof(double));
  mahal = (double *)malloc(d*sizeof(double));
  memset(alphasb, 0, k * sizeof(double));
  memset(meansb, 0, d * k * sizeof(double));
  memset(icfb, 0, icf_sz * k * sizeof(double));
  memset(lseb, 0, k * sizeof(double));
  memset(Ldiagb, 0, d * sizeof(double));
  memset(xcenteredb, 0, d * sizeof(double));
  memset(mahalb, 0, d * sizeof(double));
  for (ix = 0; ix < n; ++ix)
    for (ik = 0; ik < k; ++ik) {
      icf_off = ik*icf_sz;
      sumlog_Ldiag = 0.;
      for (id = 0; id < d; ++id) {
        sumlog_Ldiag = sumlog_Ldiag + icf[icf_off + id];
        pushreal8(Ldiag[id]);
        Ldiag[id] = exp(icf[icf_off + id]);
      }
      for (id = 0; id < d; ++id) {
        pushreal8(xcentered[id]);
        xcentered[id] = x[ix*d + id] - means[ik*d + id];
        pushreal8(mahal[id]);
        mahal[id] = Ldiag[id] * xcentered[id];
      }
      Lparamsidx = d;
      for (i = 0; i < d; ++i) {
        adFrom = i + 1;
        for (j = adFrom; j < d; ++j) {
          pushreal8(mahal[j]);
          mahal[j] = mahal[j] + icf[icf_off + Lparamsidx] * xcentered[i]
            ;
          pushinteger4(Lparamsidx);
          Lparamsidx = Lparamsidx + 1;
        }
        pushinteger4(adFrom);
      }
      sqsum_mahal = 0.;
      for (id = 0; id < d; ++id)
        sqsum_mahal = sqsum_mahal + mahal[id] * mahal[id];
      pushreal8(lse[ik]);
      lse[ik] = alphas[ik] + sumlog_Ldiag - 0.5*sqsum_mahal;
    }
  result1b = *errb;
  log_wish_prior_res = log_wishart_prior_b(d, k, wishart, icf, icfb, result1b);
  slse = 0.;
  slseb = *errb;
  lse_alphasb = -(n*(*errb));
  lse_alphas = logsumexp_b(k, alphas, alphasb, lse_alphasb);
  for (ix = n - 1; ix > -1; --ix) {
    result1b = slseb;
    slse = slse + logsumexp_b(k, lse, lseb, result1b);
    for (ik = k - 1; ik > -1; --ik) {
      popreal8(&lse[ik]);
      alphasb[ik] = alphasb[ik] + lseb[ik];
      sumlog_Ldiagb = lseb[ik];
      sqsum_mahalb = -(0.5*lseb[ik]);
      lseb[ik] = 0.0;
      for (id = d - 1; id > -1; --id)
        mahalb[id] = mahalb[id] + 2 * mahal[id] * sqsum_mahalb;
      icf_off = ik*icf_sz;
      for (i = d - 1; i > -1; --i) {
        popinteger4(&adFrom);
        for (j = d - 1; j > adFrom - 1; --j) {
          popinteger4(&Lparamsidx);
          popreal8(&mahal[j]);
          icfb[icf_off + Lparamsidx] = icfb[icf_off + Lparamsidx] +
            xcentered[i] * mahalb[j];
          xcenteredb[i] = xcenteredb[i] + icf[icf_off + Lparamsidx] *
            mahalb[j];
        }
      }
      for (id = d - 1; id > -1; --id) {
        popreal8(&mahal[id]);
        Ldiagb[id] = Ldiagb[id] + xcentered[id] * mahalb[id];
        xcenteredb[id] = xcenteredb[id] + Ldiag[id] * mahalb[id];
        mahalb[id] = 0.0;
        popreal8(&xcentered[id]);
        meansb[ik*d + id] = meansb[ik*d + id] - xcenteredb[id];
        xcenteredb[id] = 0.0;
      }
      for (id = d - 1; id > -1; --id) {
        popreal8(&Ldiag[id]);
        icfb[icf_off + id] = icfb[icf_off + id] + exp(icf[icf_off + id])
          *Ldiagb[id];
        Ldiagb[id] = 0.0;
        icfb[icf_off + id] = icfb[icf_off + id] + sumlog_Ldiagb;
      }
    }
  }
  free(mahal);
  free(mahalb);
  free(xcentered);
  free(xcenteredb);
  free(Ldiag);
  free(Ldiagb);
  free(lse);
  free(lseb);
  *err = CONSTANT + slse - n*lse_alphas + log_wish_prior_res;
  *errb = 0.0;
}
