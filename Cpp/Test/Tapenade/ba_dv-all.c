/*        Generated by TAPENADE     (INRIA, Tropics team)
Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
*/
#include "ba_dv.h"
#include <stdlib.h>
#include <math.h>
#include <float.h>
/*  Hint: NB_DIRS_REPROJ_DV should be the maximum number of differentiation directions
*/

/*
Differentiation of rodrigues_rotate_point in forward (tangent) mode:
variations   of useful results: *rotatedPt
with respect to varying inputs: *rot *pt
Plus diff mem management of: rot:in rotatedPt:in pt:in
*/
void rodrigues_rotate_point_dv(double *rot, double(*rotd)[NB_DIRS_REPROJ_DV], double
  *pt, double(*ptd)[NB_DIRS_REPROJ_DV], double *rotatedPt, double(*rotatedPtd)
  [NB_DIRS_REPROJ_DV], int nbdirs) {
  int i;
  double theta, costheta, sintheta, theta_inverse, w[3], w_cross_pt[3], tmp;
  double thetad[NB_DIRS_REPROJ_DV], costhetad[NB_DIRS_REPROJ_DV], sinthetad[NB_DIRS_REPROJ_DV],
    theta_inversed[NB_DIRS_REPROJ_DV], wd[3][NB_DIRS_REPROJ_DV], w_cross_ptd[3][NB_DIRS_REPROJ_DV],
    tmpd[NB_DIRS_REPROJ_DV];
  int nd;
  int ii1;
  // norm of rot
  theta = 0.;
  for (nd = 0; nd < nbdirs; ++nd)
    thetad[nd] = 0.0;
  for (i = 0; i < 3; ++i) {
    for (nd = 0; nd < nbdirs; ++nd)
      thetad[nd] = thetad[nd] + rotd[i][nd] * rot[i] + rot[i] * rotd[i][nd];
    theta = theta + rot[i] * rot[i];
  }
  for (nd = 0; nd < nbdirs; ++nd) {
    thetad[nd] = (theta == 0.0 ? 0.0 : thetad[nd] / (2.0*sqrt(theta)));
    for (ii1 = 0; ii1 < 3; ++ii1)
      wd[ii1][nd] = 0.0;
  }
  theta = sqrt(theta);
  theta_inverse = 1.0 / theta;
  for (nd = 0; nd < nbdirs; ++nd) {
    costhetad[nd] = -(thetad[nd] * sin(theta));
    sinthetad[nd] = thetad[nd] * cos(theta);
    theta_inversed[nd] = -(thetad[nd] / (theta*theta));
    wd[0][nd] = rotd[0][nd] * theta_inverse + rot[0] * theta_inversed[nd];
  }
  costheta = cos(theta);
  sintheta = sin(theta);
  w[0] = rot[0] * theta_inverse;
  for (nd = 0; nd < nbdirs; ++nd)
    wd[1][nd] = rotd[1][nd] * theta_inverse + rot[1] * theta_inversed[nd];
  w[1] = rot[1] * theta_inverse;
  for (nd = 0; nd < nbdirs; ++nd) {
    wd[2][nd] = rotd[2][nd] * theta_inverse + rot[2] * theta_inversed[nd];
    for (ii1 = 0; ii1 < 3; ++ii1)
      w_cross_ptd[ii1][nd] = 0.0;
  }
  w[2] = rot[2] * theta_inverse;
  for (nd = 0; nd < nbdirs; ++nd)
    w_cross_ptd[0][nd] = wd[1][nd] * pt[2] + w[1] * ptd[2][nd] - wd[2][nd] * pt[
      1] - w[2] * ptd[1][nd];
      w_cross_pt[0] = w[1] * pt[2] - w[2] * pt[1];
      for (nd = 0; nd < nbdirs; ++nd)
        w_cross_ptd[1][nd] = wd[2][nd] * pt[0] + w[2] * ptd[0][nd] - wd[0][nd] * pt[
          2] - w[0] * ptd[2][nd];
          w_cross_pt[1] = w[2] * pt[0] - w[0] * pt[2];
          for (nd = 0; nd < nbdirs; ++nd)
            w_cross_ptd[2][nd] = wd[0][nd] * pt[1] + w[0] * ptd[1][nd] - wd[1][nd] * pt[
              0] - w[1] * ptd[0][nd];
              w_cross_pt[2] = w[0] * pt[1] - w[1] * pt[0];
              tmp = (w[0] * pt[0] + w[1] * pt[1] + w[2] * pt[2])*(1. - costheta);
              for (nd = 0; nd < nbdirs; ++nd) {
                tmpd[nd] = (wd[0][nd] * pt[0] + w[0] * ptd[0][nd] + wd[1][nd] * pt[1] + w[1] * ptd[1
            ][nd] + wd[2][nd] * pt[2] + w[2] * ptd[2][nd])*(1. - costheta) - (w[0] * pt[0]
              + w[1] * pt[1] + w[2] * pt[2])*costhetad[nd];
                rotatedPtd[0][nd] = ptd[0][nd] * costheta + pt[0] * costhetad[nd] +
                  w_cross_ptd[0][nd] * sintheta + w_cross_pt[0] * sinthetad[nd] + wd[0][
                    nd] * tmp + w[0] * tmpd[nd];
              }
              rotatedPt[0] = pt[0] * costheta + w_cross_pt[0] * sintheta + w[0] * tmp;
              for (nd = 0; nd < nbdirs; ++nd)
                rotatedPtd[1][nd] = ptd[1][nd] * costheta + pt[1] * costhetad[nd] +
                w_cross_ptd[1][nd] * sintheta + w_cross_pt[1] * sinthetad[nd] + wd[1][
                  nd] * tmp + w[1] * tmpd[nd];
                  rotatedPt[1] = pt[1] * costheta + w_cross_pt[1] * sintheta + w[1] * tmp;
                  for (nd = 0; nd < nbdirs; ++nd)
                    rotatedPtd[2][nd] = ptd[2][nd] * costheta + pt[2] * costhetad[nd] +
                    w_cross_ptd[2][nd] * sintheta + w_cross_pt[2] * sinthetad[nd] + wd[2][
                      nd] * tmp + w[2] * tmpd[nd];
                      rotatedPt[2] = pt[2] * costheta + w_cross_pt[2] * sintheta + w[2] * tmp;
}
/*  Hint: NB_DIRS_REPROJ_DV should be the maximum number of differentiation directions
*/


/*
Differentiation of radial_distort in forward (tangent) mode:
variations   of useful results: *proj
with respect to varying inputs: *rad_params *proj
Plus diff mem management of: rad_params:in proj:in
*/
void radial_distort_dv(double *rad_params, double(*rad_paramsd)[NB_DIRS_REPROJ_DV],
  double *proj, double(*projd)[NB_DIRS_REPROJ_DV], int nbdirs) {
  double rsq, L;
  double rsqd[NB_DIRS_REPROJ_DV], Ld[NB_DIRS_REPROJ_DV];
  int nd;
  rsq = proj[0] * proj[0] + proj[1] * proj[1];
  L = 1 + rad_params[0] * rsq + rad_params[1] * rsq*rsq;
  for (nd = 0; nd < nbdirs; ++nd) {
    rsqd[nd] = projd[0][nd] * proj[0] + proj[0] * projd[0][nd] + projd[1][nd] *
      proj[1] + proj[1] * projd[1][nd];
    Ld[nd] = rad_paramsd[0][nd] * rsq + rad_params[0] * rsqd[nd] + rad_paramsd
      [1][nd] * (rsq*rsq) + rad_params[1] * (rsqd[nd] * rsq + rsq*rsqd[nd]);
    projd[0][nd] = projd[0][nd] * L + proj[0] * Ld[nd];
  }
  proj[0] = proj[0] * L;
  for (nd = 0; nd < nbdirs; ++nd)
    projd[1][nd] = projd[1][nd] * L + proj[1] * Ld[nd];
  proj[1] = proj[1] * L;
}
/*  Hint: NB_DIRS_REPROJ_DV should be the maximum number of differentiation directions
*/


/*
Differentiation of project in forward (tangent) mode:
variations   of useful results: *proj
with respect to varying inputs: *cam *X
Plus diff mem management of: cam:in X:in proj:in-out
*/
void project_dv(double *cam, double(*camd)[NB_DIRS_REPROJ_DV], double *X, double(*Xd
  )[NB_DIRS_REPROJ_DV], double *proj, double(*projd)[NB_DIRS_REPROJ_DV], int nbdirs) {
  double *C;
  double(*Cd)[NB_DIRS_REPROJ_DV];
  double Xo[3], Xcam[3];
  double Xod[3][NB_DIRS_REPROJ_DV], Xcamd[3][NB_DIRS_REPROJ_DV];
  int nd;
  int ii1;
  Cd = &camd[3];
  C = &cam[3];
  for (nd = 0; nd < nbdirs; ++nd) {
    for (ii1 = 0; ii1 < 3; ++ii1)
      Xod[ii1][nd] = 0.0;
    Xod[0][nd] = Xd[0][nd] - Cd[0][nd];
  }
  Xo[0] = X[0] - C[0];
  for (nd = 0; nd < nbdirs; ++nd)
    Xod[1][nd] = Xd[1][nd] - Cd[1][nd];
  Xo[1] = X[1] - C[1];
  for (nd = 0; nd < nbdirs; ++nd)
    Xod[2][nd] = Xd[2][nd] - Cd[2][nd];
  Xo[2] = X[2] - C[2];
  rodrigues_rotate_point_dv(&cam[0], &camd[0], Xo, Xod, Xcam, Xcamd, nbdirs)
    ;
  for (nd = 0; nd < nbdirs; ++nd)
    projd[0][nd] = (Xcamd[0][nd] * Xcam[2] - Xcam[0] * Xcamd[2][nd]) / (Xcam[2] *
      Xcam[2]);
  proj[0] = Xcam[0] / Xcam[2];
  for (nd = 0; nd < nbdirs; ++nd)
    projd[1][nd] = (Xcamd[1][nd] * Xcam[2] - Xcam[1] * Xcamd[2][nd]) / (Xcam[2] *
      Xcam[2]);
  proj[1] = Xcam[1] / Xcam[2];
  radial_distort_dv(&cam[9], &camd[9], proj, projd, nbdirs);
  for (nd = 0; nd < nbdirs; ++nd)
    projd[0][nd] = projd[0][nd] * cam[6] + proj[0] * camd[6][nd] + camd[7][nd]
    ;
  proj[0] = proj[0] * cam[6] + cam[7];
  for (nd = 0; nd < nbdirs; ++nd)
    projd[1][nd] = projd[1][nd] * cam[6] + proj[1] * camd[6][nd] + camd[8][nd]
    ;
  proj[1] = proj[1] * cam[6] + cam[8];
}
/*  Hint: NB_DIRS_REPROJ_DV should be the maximum number of differentiation directions
*/


/*
Differentiation of computeReprojError in forward (tangent) mode:
variations   of useful results: *err
with respect to varying inputs: *w *cam *X
RW status of diff variables: *err:out *w:in *cam:in *X:in
Plus diff mem management of: err:in w:in cam:in X:in
*/
void computeReprojError_dv(double *cam, double(*camd)[NB_DIRS_REPROJ_DV], double *X,
  double(*Xd)[NB_DIRS_REPROJ_DV], double *w, double(*wd)[NB_DIRS_REPROJ_DV], double
  feat_x, double feat_y, double *err, double(*errd)[NB_DIRS_REPROJ_DV], int
  nbdirs) {
  double proj[2];
  double projd[2][NB_DIRS_REPROJ_DV];
  int nd;
  project_dv(cam, camd, X, Xd, proj, projd, nbdirs);
  for (nd = 0; nd < nbdirs; ++nd)
    errd[0][nd] = (*wd)[nd] * (proj[0] - feat_x) + (*w)*projd[0][nd];
  err[0] = (*w)*(proj[0] - feat_x);
  for (nd = 0; nd < nbdirs; ++nd)
    errd[1][nd] = (*wd)[nd] * (proj[1] - feat_y) + (*w)*projd[1][nd];
  err[1] = (*w)*(proj[1] - feat_y);
}

/*
Differentiation of computeFocalPriorError in forward (tangent) mode:
variations   of useful results: *err
with respect to varying inputs: *cam1 *cam2 *cam3
RW status of diff variables: *err:out *cam1:in *cam2:in *cam3:in
Plus diff mem management of: err:in cam1:in cam2:in cam3:in
*/
// temporal prior
void computeFocalPriorError_dv(double *cam1, double(*cam1d)[NB_DIRS_F_PRIOR_DV],
  double *cam2, double(*cam2d)[NB_DIRS_F_PRIOR_DV], double *cam3, double(*cam3d
    )[NB_DIRS_F_PRIOR_DV], double *err, double(*errd)[NB_DIRS_F_PRIOR_DV], int nbdirs) {
  int nd;
  for (nd = 0; nd < nbdirs; ++nd)
    (*errd)[nd] = cam1d[6][nd] - 2 * cam2d[6][nd] + cam3d[6][nd];
  *err = cam1[6] - 2 * cam2[6] + cam3[6];
}

/*
Differentiation of computeZachWeightError in forward (tangent) mode:
variations   of useful results: *err
with respect to varying inputs: *w
RW status of diff variables: *err:out *w:in
Plus diff mem management of: err:in w:in
*/
void computeZachWeightError_dv(double *w, double *wd, double *err
  , double *errd) {
  *errd = -((*wd) * (*w)) - (*w)*(*wd);
  *err = 1 - (*w)*(*w);
}