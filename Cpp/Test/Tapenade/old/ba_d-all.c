/*        Generated by TAPENADE     (INRIA, Tropics team)
    Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
*/
#include <stdlib.h>
#include <math.h>
#include <float.h>

/*
  Differentiation of rodrigues_rot in forward (tangent) mode:
   variations   of useful results: *R
   with respect to varying inputs: *rot *R
   Plus diff mem management of: rot:in R:in
*/
// rot 3 rotation parameters
// R 3*3 rotation matrix (column major)
// easy to understand calculation in matlab:
//	theta = sqrt(sum(w. ^ 2));
//	n = w / theta;
//	n_x = au_cross_matrix(n);
//	R = eye(3) + n_x*sin(theta) + n_x*n_x*(1 - cos(theta));
void rodrigues_rot_d(double *rot, double *rotd, double *R, double *Rd) {
    double w1, w2, w3, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14
    , t15, t17, t23, t32;
    double w1d, w2d, w3d, t2d, t3d, t4d, t5d, t6d, t7d, t8d, t9d, t10d, t11d, 
    t12d, t13d, t14d, t15d, t17d, t23d, t32d;
    w1d = rotd[0];
    w1 = rot[0];
    w2d = rotd[1];
    w2 = rot[1];
    w3d = rotd[2];
    w3 = rot[2];
    t2d = w2d*w2 + w2*w2d;
    t2 = w2*w2;
    t3d = w1d*w1 + w1*w1d;
    t3 = w1*w1;
    t4d = w3d*w3 + w3*w3d;
    t4 = w3*w3;
    t5d = t2d + t3d + t4d;
    t5 = t2 + t3 + t4 + (double)2.22044604925031308085e-16L;
    t7d = (t5 == 0.0 ? 0.0 : t5d/(2.0*sqrt(t5)));
    t7 = sqrt(t5);
    t8d = -(t7d*sin(t7));
    t8 = cos(t7);
    t10d = t7d*cos(t7);
    t10 = sin(t7);
    t9d = t8d;
    t9 = t8 - 1.0;
    t11d = -(t7d/(t7*t7));
    t11 = 1./t7;
    t13d = (t10d*t11+t10*t11d)*w2 + t10*t11*w2d;
    t13 = t10*t11*w2;
    t6d = -(t5d/(t5*t5));
    t6 = 1./t5;
    t12d = t4d*t6 + t4*t6d;
    t12 = t4*t6;
    t14d = t3d*t6 + t3*t6d;
    t14 = t3*t6;
    t15d = t2d*t6 + t2*t6d;
    t15 = t2*t6;
    t17d = t12d + t15d;
    t17 = t12 + t15;
    t23d = t12d + t14d;
    t23 = t12 + t14;
    t32d = t14d + t15d;
    t32 = t14 + t15;
    // first row
    Rd[0*3 + 0] = t9d*t17 + t9*t17d;
    R[0*3 + 0] = t9*t17 + 1.;
    Rd[1*3 + 0] = -(t10d*t11*w3) - t10*(t11d*w3+t11*w3d) - (t6d*t9+t6*t9d)*w1*
        w2 - t6*t9*(w1d*w2+w1*w2d);
    R[1*3 + 0] = -t10*t11*w3 - t6*t9*w1*w2;
    Rd[2*3 + 0] = t13d - (t6d*t9+t6*t9d)*w1*w3 - t6*t9*(w1d*w3+w1*w3d);
    R[2*3 + 0] = t13 - t6*t9*w1*w3;
    // second row
    Rd[0*3 + 1] = (t10d*t11+t10*t11d)*w3 + t10*t11*w3d - (t6d*t9+t6*t9d)*w1*w2
        - t6*t9*(w1d*w2+w1*w2d);
    R[0*3 + 1] = t10*t11*w3 - t6*t9*w1*w2;
    Rd[1*3 + 1] = t9d*t23 + t9*t23d;
    R[1*3 + 1] = t9*t23 + 1.0;
    Rd[2*3 + 1] = -(t10d*t11*w1) - t10*(t11d*w1+t11*w1d) - (t6d*t9+t6*t9d)*w2*
        w3 - t6*t9*(w2d*w3+w2*w3d);
    R[2*3 + 1] = -t10*t11*w1 - t6*t9*w2*w3;
    // third row
    Rd[0*3 + 2] = -t13d - (t6d*t9+t6*t9d)*w1*w3 - t6*t9*(w1d*w3+w1*w3d);
    R[0*3 + 2] = -t13 - t6*t9*w1*w3;
    Rd[1*3 + 2] = (t10d*t11+t10*t11d)*w1 + t10*t11*w1d - (t6d*t9+t6*t9d)*w2*w3
        - t6*t9*(w2d*w3+w2*w3d);
    R[1*3 + 2] = t10*t11*w1 - t6*t9*w2*w3;
    Rd[2*3 + 2] = t9d*t32 + t9*t32d;
    R[2*3 + 2] = t9*t32 + 1.0;
}

/*
  Differentiation of radial_distort in forward (tangent) mode:
   variations   of useful results: *proj
   with respect to varying inputs: *rad_params *proj
   Plus diff mem management of: proj:in
*/
// rad_params 2 radial distortion parameters
// proj 2 projection to be distorted
void radial_distort_d(double *rad_params, double *rad_paramsd, double *proj, 
        double *projd) {
    double rsq = proj[0]*proj[0] + proj[1]*proj[1];
    double rsqd = projd[0]*proj[0] + proj[0]*projd[0] + projd[1]*proj[1] + 
    proj[1]*projd[1];
    double L = 1 + rad_params[0]*rsq + rad_params[1]*rsq*rsq;
    double Ld = rad_paramsd[0]*rsq + rad_params[0]*rsqd + rad_paramsd[1]*(rsq*
    rsq) + rad_params[1]*(rsqd*rsq+rsq*rsqd);
    projd[0] = projd[0]*L + proj[0]*Ld;
    proj[0] = proj[0]*L;
    projd[1] = projd[1]*L + proj[1]*Ld;
    proj[1] = proj[1]*L;
}

/*
  Differentiation of project in forward (tangent) mode:
   variations   of useful results: *proj
   with respect to varying inputs: *cam *R *X *proj
   Plus diff mem management of: cam:in R:in X:in proj:in-out
*/
// cam 11 cameras in format [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]
//            r1, r2, r3 are angle - axis rotation parameters(Rodrigues)
//			  [C1 C2 C3]' is the camera center
//            f is the focal length in pixels
//			  [u0 v0]' is the principal point
//            k1, k2 are radial distortion parameters
// R 3*3 column major rotation matrix
// X 3 point
// proj 2 projection
// projection: 
// Xcam = R * (X - C)
// distorted = radial_distort(projective2euclidean(Xcam), radial_parameters)
// proj = distorted * f + principal_point
// err = sqsum(proj - measurement)
void project_d(double *cam, double *camd, double *R, double *Rd, double *X, 
        double *Xd, double *proj, double *projd) {
    int i, k, Ridx;
    double *C;
    double *Cd;
    double Xo[3], Xcam[3];
    double Xod[3], Xcamd[3];
    int ii1;
    Cd = &camd[3];
    C = &cam[3];
    for (ii1 = 0; ii1 < 3; ++ii1)
        Xod[ii1] = 0.0;
    Xod[0] = Xd[0] - Cd[0];
    Xo[0] = X[0] - C[0];
    Xod[1] = Xd[1] - Cd[1];
    Xo[1] = X[1] - C[1];
    Xod[2] = Xd[2] - Cd[2];
    Xo[2] = X[2] - C[2];
    Xcamd[0] = 0.0;
    Xcam[0] = 0.;
    Xcamd[1] = 0.0;
    Xcam[1] = 0.;
    Xcamd[2] = 0.0;
    Xcam[2] = 0.;
    Ridx = 0;
    for (ii1 = 0; ii1 < 3; ++ii1)
        Xcamd[ii1] = 0.0;
    for (i = 0; i < 3; ++i)
        for (k = 0; k < 3; ++k) {
            Xcamd[k] = Xcamd[k] + Rd[Ridx]*Xo[i] + R[Ridx]*Xod[i];
            Xcam[k] = Xcam[k] + R[Ridx]*Xo[i];
            Ridx = Ridx + 1;
        }
    projd[0] = (Xcamd[0]*Xcam[2]-Xcam[0]*Xcamd[2])/(Xcam[2]*Xcam[2]);
    proj[0] = Xcam[0]/Xcam[2];
    projd[1] = (Xcamd[1]*Xcam[2]-Xcam[1]*Xcamd[2])/(Xcam[2]*Xcam[2]);
    proj[1] = Xcam[1]/Xcam[2];
    radial_distort_d(&cam[9], &camd[9], proj, projd);
    projd[0] = projd[0]*cam[6] + proj[0]*camd[6] + camd[7];
    proj[0] = proj[0]*cam[6] + cam[7];
    projd[1] = projd[1]*cam[6] + proj[1]*camd[6] + camd[8];
    proj[1] = proj[1]*cam[6] + cam[8];
}

/*
  Differentiation of ba in forward (tangent) mode:
   variations   of useful results: *err
   with respect to varying inputs: *cams *X
   RW status of diff variables: *err:out *cams:in *X:in
   Plus diff mem management of: err:in cams:in X:in
*/
// n number of cameras
// m number of points
// p number of observations
// cams 11*n cameras in format [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]
//            r1, r2, r3 are angle - axis rotation parameters(Rodrigues)
//			  [C1 C2 C3]' is the camera center
//            f is the focal length in pixels
//			  [u0 v0]' is the principal point
//            k1, k2 are radial distortion parameters
// X 3*m points
// obs 2*p observations (pairs cameraIdx, pointIdx)
// feats 2*p features (x,y coordinates corresponding to observations)
// err p squared errors of observations
// projection: 
// Xcam = R * (X - C)
// distorted = radial_distort(projective2euclidean(Xcam), radial_parameters)
// proj = distorted * f + principal_point
// err = sqsum(proj - measurement)
void ba_d(int n, int m, int p, double *cams, double *camsd, double *X, double 
        *Xd, int *obs, double *feats, double *err, double *errd) {
    int i;
    int nCamParams = 11;
    double *R = (double *)malloc(3*3*n*sizeof(double));
    double *Rd = (double *)malloc(3*3*n*sizeof(double));
    double *proj = (double *)malloc(2*sizeof(double));
    double *projd = (double *)malloc(2*sizeof(double));
    *Rd = 0.0;
    for (i = 0; i < n; ++i)
        rodrigues_rot_d(&cams[i*nCamParams], &camsd[i*nCamParams], &R[i*3*3], 
                        &Rd[i*3*3]);
    *projd = 0.0;
    *errd = 0.0;
    for (i = 0; i < p; ++i) {
        int camIdx = obs[i*2 + 0];
        int ptIdx = obs[i*2 + 1];
        project_d(&cams[camIdx*nCamParams], &camsd[camIdx*nCamParams], &R[
                  camIdx*3*3], &Rd[camIdx*3*3], &X[ptIdx*3], &Xd[ptIdx*3], 
                  proj, projd);
        proj[0] = proj[0] - feats[i*2 + 0];
        proj[1] = proj[1] - feats[i*2 + 1];
        errd[i] = projd[0]*proj[0] + proj[0]*projd[0] + projd[1]*proj[1] + 
            proj[1]*projd[1];
        err[i] = proj[0]*proj[0] + proj[1]*proj[1];
    }
    free(Rd);
    free(R);
    free(projd);
    free(proj);
    err[0] = err[0] + (cams[0] - cams[0] + (X[0] - X[0]));
}
