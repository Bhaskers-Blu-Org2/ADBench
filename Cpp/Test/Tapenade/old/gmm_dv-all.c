/*        Generated by TAPENADE     (INRIA, Tropics team)
    Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
*/
/*
#include <math.h>
#include <stdlib.h>

//#include "gmm.h"
// This throws error on n<1
void arr_max_dv(int n, double *x, double (*xd)[NBDirsMax], double *arr_max, 
        double arr_maxd[NBDirsMax], int nbdirs) {
    double m;
    double md[NBDirsMax];
    int nd;
    for (nd = 0; nd < nbdirs; ++nd)
        md[nd] = xd[0][nd];
    m = x[0];
    int i;
    for (i = 1; i < n; ++i)
        if (x[i] > m) {
            for (nd = 0; nd < nbdirs; ++nd)
                md[nd] = xd[i][nd];
            m = x[i];
        }
    *arr_max = m;
    for (nd = 0; nd < nbdirs; ++nd)
        arr_maxd[nd] = md[nd];
}


void logsumexp_dv(int n, double *x, double (*xd)[NBDirsMax], double *logsumexp
        , double logsumexpd[NBDirsMax], int nbdirs) {
    double mx;
    double mxd[NBDirsMax];
    double arg1;
    double arg1d[NBDirsMax];
    arr_max_dv(n, x, xd, &mx, mxd, nbdirs);
    double semx;
    double semxd[NBDirsMax];
    semx = 0.;
    int i;
    int nd;
    for (nd = 0; nd < nbdirs; ++nd)
        semxd[nd] = 0.0;
    for (i = 0; i < n; ++i) {
        arg1 = x[i] - mx;
        for (nd = 0; nd < nbdirs; ++nd) {
            arg1d[nd] = xd[i][nd] - mxd[nd];
            semxd[nd] = semxd[nd] + arg1d[nd]*exp(arg1);
        }
        semx += exp(x[i] - mx);
    }
    *logsumexp = log(semx) + mx;
    for (nd = 0; nd < nbdirs; ++nd)
        logsumexpd[nd] = semxd[nd]/semx + mxd[nd];
}


// d dim
// k number of gaussians
// n number of points
// alphas k logs of mixture weights (unnormalized), so
//			weights = exp(log_alphas) / sum(exp(log_alphas))
// means d*k component means
// inv_cov_factors (d*(d+1)/2)*k parametrizing lower triangular 
//					square roots of inverse covariances log of diagonal 
//					is first d params
// x d*n points
// err 1 output
// To generate params in MATLAB given covariance C :
//           L = inv(chol(C, 'lower'));
//           inv_cov_factor = [log(diag(L)); L(au_tril_indices(d, -1))]
void gmm_dv(int d, int k, int n, double *alphas, double (*alphasd)[NBDirsMax],
        double *means, double (*meansd)[NBDirsMax], double *inv_cov_factors, 
        double (*inv_cov_factorsd)[NBDirsMax], double *x, double *err, double 
        (*errd)[NBDirsMax], int nbdirs) {
    const double PI = 3.14159265359;
    const double CONSTANT = 1/pow(sqrt(2*PI), d);
    int ik, ix, id, i, j, icf_off, Lparamsidx;
    int icf_sz;
    double result1;
    double result1d[NBDirsMax];
    icf_sz = d*(d+1)/2;
    double *lse = (double *)malloc(k*sizeof(double));
    double *lsed = (double (*)[NBDirsMax])malloc(k*sizeof(double)*nbdirs);
    double *Ldiag = (double *)malloc(d*sizeof(double));
    double *Ldiagd = (double (*)[NBDirsMax])malloc(d*sizeof(double)*nbdirs);
    double *xcentered = (double *)malloc(d*sizeof(double));
    double *xcenteredd = (double (*)[NBDirsMax])malloc(d*sizeof(double)*nbdirs
    );
    double *mahal = (double *)malloc(d*sizeof(double));
    double *mahald = (double (*)[NBDirsMax])malloc(d*sizeof(double)*nbdirs);
    double sumlog_Ldiag, sqsum_mahal, slse, lse_alphas;
    double sumlog_Ldiagd[NBDirsMax], sqsum_mahald[NBDirsMax], slsed[NBDirsMax]
    , lse_alphasd[NBDirsMax];
    int nd;
    slse = 0.;
    for (nd = 0; nd < nbdirs; ++nd) {
        mahald[nd] = 0.0;
        xcenteredd[nd] = 0.0;
        Ldiagd[nd] = 0.0;
        lsed[nd] = 0.0;
        slsed[nd] = 0.0;
    }
    for (ix = 0; ix < n; ++ix) {
        for (ik = 0; ik < k; ++ik) {
            icf_off = ik*icf_sz;
            sumlog_Ldiag = 0.;
            for (nd = 0; nd < nbdirs; ++nd)
                sumlog_Ldiagd[nd] = 0.0;
            for (id = 0; id < d; ++id) {
                for (nd = 0; nd < nbdirs; ++nd) {
                    sumlog_Ldiagd[nd] = sumlog_Ldiagd[nd] + inv_cov_factorsd[
                        icf_off + id][nd];
                    Ldiagd[id][nd] = inv_cov_factorsd[icf_off+id][nd]*exp(
                        inv_cov_factors[icf_off+id]);
                }
                sumlog_Ldiag = sumlog_Ldiag + inv_cov_factors[icf_off + id];
                Ldiag[id] = exp(inv_cov_factors[icf_off + id]);
            }
            for (id = 0; id < d; ++id) {
                xcentered[id] = x[ix*d + id] - means[ik*d + id];
                for (nd = 0; nd < nbdirs; ++nd) {
                    xcenteredd[id][nd] = -meansd[ik*d+id][nd];
                    mahald[id][nd] = Ldiagd[id][nd]*xcentered[id] + Ldiag[id]*
                        xcenteredd[id][nd];
                }
                mahal[id] = Ldiag[id]*xcentered[id];
            }
            Lparamsidx = d;
            for (i = 0; i < d; ++i)
                for (j = i+1; j < d; ++j) {
                    for (nd = 0; nd < nbdirs; ++nd)
                        mahald[j][nd] = mahald[j][nd] + inv_cov_factorsd[
                            icf_off+Lparamsidx][nd]*xcentered[i] + 
                            inv_cov_factors[icf_off+Lparamsidx]*xcenteredd[i][
                            nd];
                    mahal[j] = mahal[j] + inv_cov_factors[icf_off+Lparamsidx]*
                        xcentered[i];
                    Lparamsidx = Lparamsidx + 1;
                }
            sqsum_mahal = 0.;
            for (nd = 0; nd < nbdirs; ++nd)
                sqsum_mahald[nd] = 0.0;
            for (id = 0; id < d; ++id) {
                for (nd = 0; nd < nbdirs; ++nd)
                    sqsum_mahald[nd] = sqsum_mahald[nd] + mahald[id][nd]*mahal
                        [id] + mahal[id]*mahald[id][nd];
                sqsum_mahal = sqsum_mahal + mahal[id]*mahal[id];
            }
            for (nd = 0; nd < nbdirs; ++nd)
                lsed[ik][nd] = alphasd[ik][nd] + sumlog_Ldiagd[nd] - 0.5*
                    sqsum_mahald[nd];
            lse[ik] = alphas[ik] + sumlog_Ldiag - 0.5*sqsum_mahal;
        }
        logsumexp_dv(k, lse, lsed, &result1, result1d, nbdirs);
        for (nd = 0; nd < nbdirs; ++nd)
            slsed[nd] = slsed[nd] + result1d[nd];
        slse = slse + result1;
    }
    free(mahald[]);
    free(mahal);
    free(xcenteredd[]);
    free(xcentered);
    free(Ldiagd[]);
    free(Ldiag);
    free(lsed[]);
    free(lse);
    logsumexp_dv(k, alphas, alphasd, &lse_alphas, lse_alphasd, nbdirs);
    for (nd = 0; nd < nbdirs; ++nd)
        errd[nd] = slsed[nd] - n*lse_alphasd[nd];
    *err = n*log(CONSTANT) + slse - n*lse_alphas;
    // this is here so that tapenade would recognize that means and inv_cov_factors are variables
    *err = *err + (means[0] + inv_cov_factors[0] - means[0] - inv_cov_factors[
        0]);
}
*/