/*        Generated by TAPENADE     (INRIA, Tropics team)
    Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
*/
#include <math.h>
#include <stdlib.h>

//#include "gmm.h"
// This throws error on n<1
double arr_max_d(int n, double *x, double *xd, double *arr_max) {
    double m = x[0];
    double md = xd[0];
    int i;
    for (i = 1; i < n; ++i)
        if (x[i] > m) {
            md = xd[i];
            m = x[i];
        }
    *arr_max = m;
    return md;
}

double logsumexp_d(int n, double *x, double *xd, double *logsumexp) {
    double mx;
    double mxd;
    mxd = arr_max_d(n, x, xd, &mx);
    double semx = 0.;
    double semxd;
    int i;
    semxd = 0.0;
    for (i = 0; i < n; ++i) {
        semxd = semxd + (xd[i]-mxd)*exp(x[i]-mx);
        semx += exp(x[i] - mx);
    }
    *logsumexp = log(semx) + mx;
    return semxd/semx + mxd;
}

// d dim
// k number of gaussians
// n number of points
// alphas k logs of mixture weights (unnormalized), so
//			weights = exp(log_alphas) / sum(exp(log_alphas))
// means d*k component means
// inv_cov_factors (d*(d+1)/2)*k parametrizing lower triangular 
//					square roots of inverse covariances log of diagonal 
//					is first d params
// x d*n points
// err 1 output
// To generate params in MATLAB given covariance C :
//           L = inv(chol(C, 'lower'));
//           inv_cov_factor = [log(diag(L)); L(au_tril_indices(d, -1))]
void gmm_d(int d, int k, int n, double *alphas, double *alphasd, double *means
        , double *meansd, double *inv_cov_factors, double *inv_cov_factorsd, 
        double *x, double *err, double *errd) {
    const double PI = 3.14159265359;
    const double CONSTANT = 1/pow(sqrt(2*PI), d);
    int ik, ix, id, i, j, icf_off, Lparamsidx;
    int icf_sz = d*(d+1)/2;
    double *lse = (double *)malloc(k*sizeof(double));
    double *lsed = (double *)malloc(k*sizeof(double));
    double *Ldiag = (double *)malloc(d*sizeof(double));
    double *Ldiagd = (double *)malloc(d*sizeof(double));
    double *xcentered = (double *)malloc(d*sizeof(double));
    double *xcenteredd = (double *)malloc(d*sizeof(double));
    double *mahal = (double *)malloc(d*sizeof(double));
    double *mahald = (double *)malloc(d*sizeof(double));
    double sumlog_Ldiag, sqsum_mahal, slse, lse_alphas;
    double sumlog_Ldiagd, sqsum_mahald, slsed, lse_alphasd;
    double result1;
    double result1d;
	slse = 0.;
	memset(mahald, 0, d*sizeof(double));
	memset(xcenteredd, 0, d*sizeof(double));
	memset(Ldiagd, 0, d*sizeof(double));
	memset(lsed, 0, k*sizeof(double));
    slsed = 0.0;
    for (ix = 0; ix < n; ++ix) {
        for (ik = 0; ik < k; ++ik) {
            icf_off = ik*icf_sz;
            sumlog_Ldiag = 0.;
            sumlog_Ldiagd = 0.0;
            for (id = 0; id < d; ++id) {
                sumlog_Ldiagd = sumlog_Ldiagd + inv_cov_factorsd[icf_off + id];
                sumlog_Ldiag = sumlog_Ldiag + inv_cov_factors[icf_off + id];
                Ldiagd[id] = inv_cov_factorsd[icf_off+id]*exp(inv_cov_factors[icf_off+id]);
                Ldiag[id] = exp(inv_cov_factors[icf_off + id]);
            }
            for (id = 0; id < d; ++id) {
                xcenteredd[id] = -meansd[ik*d+id];
                xcentered[id] = x[ix*d + id] - means[ik*d + id];
                mahald[id] = Ldiagd[id]*xcentered[id] + Ldiag[id]*xcenteredd[id];
                mahal[id] = Ldiag[id]*xcentered[id];
            }
            Lparamsidx = d;
            for (i = 0; i < d; ++i)
                for (j = i+1; j < d; ++j) {
                    mahald[j] = mahald[j] + inv_cov_factorsd[icf_off+
                        Lparamsidx]*xcentered[i] + inv_cov_factors[icf_off+
                        Lparamsidx]*xcenteredd[i];
                    mahal[j] = mahal[j] + inv_cov_factors[icf_off+Lparamsidx]*
                        xcentered[i];
                    Lparamsidx = Lparamsidx + 1;
                }
            sqsum_mahal = 0.;
            sqsum_mahald = 0.0;
            for (id = 0; id < d; ++id) {
                sqsum_mahald = sqsum_mahald + mahald[id]*mahal[id] + mahal[id]
                    *mahald[id];
                sqsum_mahal = sqsum_mahal + mahal[id]*mahal[id];
            }
            lsed[ik] = alphasd[ik] + sumlog_Ldiagd - 0.5*sqsum_mahald;
            lse[ik] = alphas[ik] + sumlog_Ldiag - 0.5*sqsum_mahal;
        }
        result1d = logsumexp_d(k, lse, lsed, &result1);
        slsed = slsed + result1d;
        slse = slse + result1;
    }
    free(mahald);
    free(mahal);
    free(xcenteredd);
    free(xcentered);
    free(Ldiagd);
    free(Ldiag);
    free(lsed);
    free(lse);
    lse_alphasd = logsumexp_d(k, alphas, alphasd, &lse_alphas);
    *errd = slsed - n*lse_alphasd;
    *err = n*log(CONSTANT) + slse - n*lse_alphas;
    // this is here so that tapenade would recognize that means and inv_cov_factors are variables
    *err = *err + (means[0] + inv_cov_factors[0] - means[0] - inv_cov_factors[
        0]);
}
