/*        Generated by TAPENADE     (INRIA, Tropics team)
    Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
*/
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include "ba.h"
/*  Hint: NBDirsMax should be the maximum number of differentiation directions
*/

/*
  Differentiation of rodrigues_rot in reverse (adjoint) mode:
   gradient     of useful results: *rot *R
   with respect to varying inputs: *rot *R
   Plus diff mem management of: rot:in R:in
*/
// rot 3 rotation parameters
// R 3*3 rotation matrix (column major)
// easy to understand calculation in matlab:
//	theta = sqrt(sum(w. ^ 2));
//	n = w / theta;
//	n_x = au_cross_matrix(n);
//	R = eye(3) + n_x*sin(theta) + n_x*n_x*(1 - cos(theta));
void rodrigues_rot_bv(double *rot, double (*rotb)[NBDirsMax], double *R, 
        double (*Rb)[NBDirsMax], int nbdirs) {
    double w1, w2, w3, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14
    , t15, t17, t23, t32;
    double w1b[NBDirsMax], w2b[NBDirsMax], w3b[NBDirsMax], t2b[NBDirsMax], t3b
    [NBDirsMax], t4b[NBDirsMax], t5b[NBDirsMax], t6b[NBDirsMax], t7b[NBDirsMax
    ], t8b[NBDirsMax], t9b[NBDirsMax], t10b[NBDirsMax], t11b[NBDirsMax], t12b[
    NBDirsMax], t13b[NBDirsMax], t14b[NBDirsMax], t15b[NBDirsMax], t17b[
    NBDirsMax], t23b[NBDirsMax], t32b[NBDirsMax];
    int nd;
    double tempb9[NBDirsMax];
    double tempb8[NBDirsMax];
    double tempb7[NBDirsMax];
    double tempb6[NBDirsMax];
    double tempb5[NBDirsMax];
    double tempb4[NBDirsMax];
    double tempb3[NBDirsMax];
    double tempb2[NBDirsMax];
    double tempb1[NBDirsMax];
    double tempb0[NBDirsMax];
    double tempb10[NBDirsMax];
    double tempb[NBDirsMax];
    w1 = rot[0];
    w2 = rot[1];
    w3 = rot[2];
    t2 = w2*w2;
    t3 = w1*w1;
    t4 = w3*w3;
    t5 = t2 + t3 + t4 + (double)2.22044604925031308085e-16L;
    t7 = sqrt(t5);
    t8 = cos(t7);
    t10 = sin(t7);
    t9 = t8 - 1.0;
    t11 = 1./t7;
    t6 = 1./t5;
    t12 = t4*t6;
    t14 = t3*t6;
    t15 = t2*t6;
    t17 = t12 + t15;
    t23 = t12 + t14;
    t32 = t14 + t15;
    // first row
    // second row
    // third row
    for (nd = 0; nd < nbdirs; ++nd) {
        t9b[nd] = t32*Rb[2*3+2][nd];
        t32b[nd] = t9*Rb[2*3+2][nd];
        Rb[2*3 + 2][nd] = 0.0;
        tempb[nd] = -(w2*w3*Rb[1*3+2][nd]);
        tempb0[nd] = -(t6*t9*Rb[1*3+2][nd]);
        t10b[nd] = w1*t11*Rb[1*3+2][nd];
        t11b[nd] = w1*t10*Rb[1*3+2][nd];
        w1b[nd] = t10*t11*Rb[1*3+2][nd];
        Rb[1*3 + 2][nd] = 0.0;
        tempb1[nd] = -(w1*w3*Rb[0*3+2][nd]);
        tempb9[nd] = -(t6*t9*Rb[0*3+2][nd]);
        t13b[nd] = -Rb[0*3+2][nd];
        Rb[0*3 + 2][nd] = 0.0;
        w1b[nd] = w1b[nd] + w3*tempb9[nd] - t10*t11*Rb[2*3+1][nd];
        tempb5[nd] = -(w2*w3*Rb[2*3+1][nd]);
        tempb6[nd] = -(t6*t9*Rb[2*3+1][nd]);
        t10b[nd] = t10b[nd] - w1*t11*Rb[2*3+1][nd];
        t11b[nd] = t11b[nd] - w1*t10*Rb[2*3+1][nd];
        Rb[2*3 + 1][nd] = 0.0;
        t9b[nd] = t9b[nd] + t6*tempb1[nd] + t23*Rb[1*3+1][nd] + t6*tempb5[nd] 
            + t6*tempb[nd];
        t23b[nd] = t9*Rb[1*3+1][nd];
        Rb[1*3 + 1][nd] = 0.0;
        w3b[nd] = w1*tempb9[nd] + t10*t11*Rb[0*3+1][nd] + w2*tempb6[nd] + w2*
            tempb0[nd];
        tempb2[nd] = -(w1*w2*Rb[0*3+1][nd]);
        tempb8[nd] = -(t6*t9*Rb[0*3+1][nd]);
        t10b[nd] = t10b[nd] + w3*t11*Rb[0*3+1][nd];
        t11b[nd] = t11b[nd] + w3*t10*Rb[0*3+1][nd];
        Rb[0*3 + 1][nd] = 0.0;
        tempb4[nd] = -(w1*w3*Rb[2*3+0][nd]);
        tempb10[nd] = -(t6*t9*Rb[2*3+0][nd]);
        t13b[nd] = t13b[nd] + Rb[2*3 + 0][nd];
        Rb[2*3 + 0][nd] = 0.0;
        w3b[nd] = w3b[nd] + w1*tempb10[nd] - t10*t11*Rb[1*3+0][nd];
        tempb3[nd] = -(w1*w2*Rb[1*3+0][nd]);
        tempb7[nd] = -(t6*t9*Rb[1*3+0][nd]);
        t10b[nd] = t10b[nd] + w2*t11*t13b[nd] - w3*t11*Rb[1*3+0][nd];
        t11b[nd] = t11b[nd] + w2*t10*t13b[nd] - w3*t10*Rb[1*3+0][nd];
        Rb[1*3 + 0][nd] = 0.0;
        t9b[nd] = t9b[nd] + t6*tempb4[nd] + t17*Rb[0*3+0][nd] + t6*tempb3[nd] 
            + t6*tempb2[nd];
        t17b[nd] = t9*Rb[0*3+0][nd];
        Rb[0*3 + 0][nd] = 0.0;
        t14b[nd] = t23b[nd] + t32b[nd];
        t15b[nd] = t17b[nd] + t32b[nd];
        t12b[nd] = t17b[nd] + t23b[nd];
        t6b[nd] = t9*tempb1[nd] + t9*tempb2[nd] + t9*tempb3[nd] + t3*t14b[nd] 
            + t4*t12b[nd] + t2*t15b[nd] + t9*tempb4[nd] + t9*tempb5[nd] + t9*
            tempb[nd];
        t8b[nd] = t9b[nd];
        t7b[nd] = cos(t7)*t10b[nd] - sin(t7)*t8b[nd] - t11b[nd]/(t7*t7);
        if (t5 == 0.0)
            t5b[nd] = -(t6b[nd]/(t5*t5));
        else
            t5b[nd] = t7b[nd]/(2.0*sqrt(t5)) - t6b[nd]/(t5*t5);
        t2b[nd] = t5b[nd] + t6*t15b[nd];
        w2b[nd] = w3*tempb6[nd] + w1*tempb7[nd] + 2*w2*t2b[nd] + t10*t11*t13b[
            nd] + w1*tempb8[nd] + w3*tempb0[nd];
        t3b[nd] = t5b[nd] + t6*t14b[nd];
        w1b[nd] = w1b[nd] + w3*tempb10[nd] + 2*w1*t3b[nd] + w2*tempb7[nd] + w2
            *tempb8[nd];
        t4b[nd] = t5b[nd] + t6*t12b[nd];
        w3b[nd] = w3b[nd] + 2*w3*t4b[nd];
        rotb[2][nd] = rotb[2][nd] + w3b[nd];
        rotb[1][nd] = rotb[1][nd] + w2b[nd];
        rotb[0][nd] = rotb[0][nd] + w1b[nd];
    }
}
/*  Hint: NBDirsMax should be the maximum number of differentiation directions
*/


/*
  Differentiation of radial_distort in reverse (adjoint) mode:
   gradient     of useful results: *rad_params *proj
   with respect to varying inputs: *rad_params *proj
   Plus diff mem management of: rad_params:in proj:in
*/
// rad_params 2 radial distortion parameters
// proj 2 projection to be distorted
void radial_distort_bv(double *rad_params, double (*rad_paramsb)[NBDirsMax], 
        double *proj, double (*projb)[NBDirsMax], int nbdirs) {
    double rsq;
    double rsqb[NBDirsMax];
    int nd;
    rsq = proj[0]*proj[0] + proj[1]*proj[1];
    double L;
    double Lb[NBDirsMax];
    L = 1 + rad_params[0]*rsq + rad_params[1]*rsq*rsq;
    pushreal8(proj[0]);
    proj[0] = proj[0]*L;
    for (nd = 0; nd < nbdirs; ++nd) {
        Lb[nd] = proj[1]*projb[1][nd];
        projb[1][nd] = L*projb[1][nd];
    }
    popreal8(&proj[0]);
    for (nd = 0; nd < nbdirs; ++nd) {
        Lb[nd] = Lb[nd] + proj[0]*projb[0][nd];
        projb[0][nd] = L*projb[0][nd];
        rad_paramsb[0][nd] = rad_paramsb[0][nd] + rsq*Lb[nd];
        rsqb[nd] = (rad_params[1]*2*rsq+rad_params[0])*Lb[nd];
        rad_paramsb[1][nd] = rad_paramsb[1][nd] + rsq*rsq*Lb[nd];
        projb[0][nd] = projb[0][nd] + 2*proj[0]*rsqb[nd];
        projb[1][nd] = projb[1][nd] + 2*proj[1]*rsqb[nd];
    }
}
/*  Hint: NBDirsMax should be the maximum number of differentiation directions
*/


/*
  Differentiation of project in reverse (adjoint) mode:
   gradient     of useful results: *cam *R *X *proj
   with respect to varying inputs: *cam *R *X *proj
   Plus diff mem management of: cam:in R:in X:in proj:in-out
*/
// cam 11 cameras in format [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]
//            r1, r2, r3 are angle - axis rotation parameters(Rodrigues)
//			  [C1 C2 C3]' is the camera center
//            f is the focal length in pixels
//			  [u0 v0]' is the principal point
//            k1, k2 are radial distortion parameters
// R 3*3 column major rotation matrix
// X 3 point
// proj 2 projection
// projection: 
// Xcam = R * (X - C)
// distorted = radial_distort(projective2euclidean(Xcam), radial_parameters)
// proj = distorted * f + principal_point
// err = sqsum(proj - measurement)
void project_bv(double *cam, double (*camb)[NBDirsMax], double *R, double (*Rb
        )[NBDirsMax], double *X, double (*Xb)[NBDirsMax], double *proj, double
        (*projb)[NBDirsMax], int nbdirs) {
    int i, k, Ridx;
    double *C;
    double (*Cb)[NBDirsMax];
    double Xo[3], Xcam[3];
    double Xob[3][NBDirsMax], Xcamb[3][NBDirsMax];
    int nd;
    double tempb0[NBDirsMax];
    double tempb[NBDirsMax];
    int ii1;
    Cb = &camb[3];
    C = &cam[3];
    Xo[0] = X[0] - C[0];
    Xo[1] = X[1] - C[1];
    Xo[2] = X[2] - C[2];
    Xcam[0] = 0.;
    Xcam[1] = 0.;
    Xcam[2] = 0.;
    Ridx = 0;
    for (i = 0; i < 3; ++i)
        for (k = 0; k < 3; ++k) {
            Xcam[k] = Xcam[k] + R[Ridx]*Xo[i];
            pushinteger4(Ridx);
            Ridx = Ridx + 1;
        }
    pushreal8(proj[0]);
    proj[0] = Xcam[0]/Xcam[2];
    pushreal8(proj[1]);
    proj[1] = Xcam[1]/Xcam[2];
    pushreal8(*proj);
    radial_distort(&cam[9], proj);
    pushreal8(proj[0]);
    proj[0] = proj[0]*cam[6] + cam[7];
    for (nd = 0; nd < nbdirs; ++nd) {
        camb[6][nd] = camb[6][nd] + proj[1]*projb[1][nd];
        camb[8][nd] = camb[8][nd] + projb[1][nd];
        projb[1][nd] = cam[6]*projb[1][nd];
    }
    popreal8(&proj[0]);
    for (nd = 0; nd < nbdirs; ++nd) {
        camb[6][nd] = camb[6][nd] + proj[0]*projb[0][nd];
        camb[7][nd] = camb[7][nd] + projb[0][nd];
        projb[0][nd] = cam[6]*projb[0][nd];
    }
    popreal8(proj);
    radial_distort_bv(&cam[9], &camb[9], proj, projb, nbdirs);
    popreal8(&proj[1]);
    for (nd = 0; nd < nbdirs; ++nd) {
        for (ii1 = 0; ii1 < 3; ++ii1)
            Xcamb[ii1][nd] = 0.0;
        tempb[nd] = projb[1][nd]/Xcam[2];
        Xcamb[1][nd] = Xcamb[1][nd] + tempb[nd];
        Xcamb[2][nd] = Xcamb[2][nd] - Xcam[1]*tempb[nd]/Xcam[2];
        projb[1][nd] = 0.0;
    }
    popreal8(&proj[0]);
    for (nd = 0; nd < nbdirs; ++nd) {
        tempb0[nd] = projb[0][nd]/Xcam[2];
        Xcamb[0][nd] = Xcamb[0][nd] + tempb0[nd];
        Xcamb[2][nd] = Xcamb[2][nd] - Xcam[0]*tempb0[nd]/Xcam[2];
        projb[0][nd] = 0.0;
    }
    for (nd = 0; nd < nbdirs; ++nd)
        for (ii1 = 0; ii1 < 3; ++ii1)
            Xob[ii1][nd] = 0.0;
    for (i = 2; i > -1; --i)
        for (k = 2; k > -1; --k) {
            popinteger4(&Ridx);
            for (nd = 0; nd < nbdirs; ++nd) {
                Rb[Ridx][nd] = Rb[Ridx][nd] + Xo[i]*Xcamb[k][nd];
                Xob[i][nd] = Xob[i][nd] + R[Ridx]*Xcamb[k][nd];
            }
        }
    for (nd = 0; nd < nbdirs; ++nd) {
        Xb[2][nd] = Xb[2][nd] + Xob[2][nd];
        Cb[2][nd] = Cb[2][nd] - Xob[2][nd];
        Xob[2][nd] = 0.0;
        Xb[1][nd] = Xb[1][nd] + Xob[1][nd];
        Cb[1][nd] = Cb[1][nd] - Xob[1][nd];
        Xob[1][nd] = 0.0;
        Xb[0][nd] = Xb[0][nd] + Xob[0][nd];
        Cb[0][nd] = Cb[0][nd] - Xob[0][nd];
    }
}
/*  Hint: NBDirsMax should be the maximum number of differentiation directions
*/


/*
  Differentiation of ba in reverse (adjoint) mode:
   gradient     of useful results: *err
   with respect to varying inputs: *err *cams *X
   RW status of diff variables: *err:in-out *cams:out *X:out
   Plus diff mem management of: err:in cams:in X:in
*/
// n number of cameras
// m number of points
// p number of observations
// cams 11*n cameras in format [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]
//            r1, r2, r3 are angle - axis rotation parameters(Rodrigues)
//			  [C1 C2 C3]' is the camera center
//            f is the focal length in pixels
//			  [u0 v0]' is the principal point
//            k1, k2 are radial distortion parameters
// X 3*m points
// obs 2*p observations (pairs cameraIdx, pointIdx)
// feats 2*p features (x,y coordinates corresponding to observations)
// err p squared errors of observations
// projection: 
// Xcam = R * (X - C)
// distorted = radial_distort(projective2euclidean(Xcam), radial_parameters)
// proj = distorted * f + principal_point
// err = sqsum(proj - measurement)
void ba_bv(int n, int m, int p, double *cams, double (*camsb)[NBDirsMax], 
        double *X, double (*Xb)[NBDirsMax], int *obs, double *feats, double *
        err, double (*errb)[NBDirsMax], int nbdirs) {
	int i, camIdx, ptIdx;
    int nCamParams = 11;
    int nd;
	double (*Rb)[NBDirsMax] = (double(*)[NBDirsMax])malloc(3 * 3 * n*sizeof(double)*NBDirsMax);
    double *R = (double *)malloc(3*3*n*sizeof(double));
	double(*projb)[NBDirsMax] = (double(*)[NBDirsMax])malloc(2 * sizeof(double)*NBDirsMax);
    double *proj = (double *)malloc(2*sizeof(double));

	for (int i = 0; i < 3*3*n; i++)
		memset(Rb[i], 0, nbdirs*sizeof(double));
	for (int i = 0; i < 2; i++)
		memset(projb[i], 0, nbdirs*sizeof(double));

    for (i = 0; i < n; ++i)
        rodrigues_rot(&cams[i*nCamParams], &R[i*3*3]);
    for (i = 0; i < p; ++i) {
		camIdx = obs[i * 2 + 0];
		ptIdx = obs[i * 2 + 1];
        pushreal8(*proj);
        project(&cams[camIdx*nCamParams], &R[camIdx*3*3], &X[ptIdx*3], proj);
        pushreal8(proj[0]);
        proj[0] = proj[0] - feats[i*2 + 0];
        pushreal8(proj[1]);
        proj[1] = proj[1] - feats[i*2 + 1];
        pushinteger4(ptIdx);
        pushinteger4(camIdx);
    }
    for (i = p-1; i > -1; --i) {
        int camIdx;
        int ptIdx;
        popinteger4(&camIdx);
        popinteger4(&ptIdx);
        for (nd = 0; nd < nbdirs; ++nd) {
            projb[0][nd] = projb[0][nd] + 2*proj[0]*errb[i][nd];
            projb[1][nd] = projb[1][nd] + 2*proj[1]*errb[i][nd];
            errb[i][nd] = 0.0;
        }
        popreal8(&proj[1]);
        popreal8(&proj[0]);
        popreal8(proj);
        project_bv(&cams[camIdx*nCamParams], &camsb[camIdx*nCamParams], &R[
                   camIdx*3*3], &Rb[camIdx*3*3], &X[ptIdx*3], &Xb[ptIdx*3], 
                   proj, projb, nbdirs);
    }
    for (i = n-1; i > -1; --i)
        rodrigues_rot_bv(&cams[i*nCamParams], &camsb[i*nCamParams], &R[i*3*3]
                         , &Rb[i*3*3], nbdirs);
    free(proj);
    free(projb);
    free(R);
    free(Rb);
}
