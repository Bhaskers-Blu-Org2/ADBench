/*        Generated by TAPENADE     (INRIA, Tropics team)
    Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
*/
#include "ba.h"
#define NB_DIRS_REPROJ_DV (BA_NCAMPARAMS+3+1)
#define NB_DIRS_F_PRIOR_DV (3*BA_NCAMPARAMS)
// rot 3 rotation parameters
// pt 3 point to be rotated
// rotatedPt 3 rotated point
// this is an efficient evaluation (part of
// the Ceres implementation)
// easy to understand calculation in matlab:
//	theta = sqrt(sum(w. ^ 2));
//	n = w / theta;
//	n_x = au_cross_matrix(n);
//	R = eye(3) + n_x*sin(theta) + n_x*n_x*(1 - cos(theta));
void rodrigues_rotate_point(double *rot, double *pt, double *rotatedPt);
void rodrigues_rotate_point_dv(double *rot, double(*rotd)[NB_DIRS_REPROJ_DV], double
	*pt, double(*ptd)[NB_DIRS_REPROJ_DV], double *rotatedPt, double(*rotatedPtd)[
		NB_DIRS_REPROJ_DV], int nbdirs);
// rad_params 2 radial distortion parameters
// proj 2 projection to be distorted
void radial_distort(double *rad_params, double *proj);
void radial_distort_dv(double *rad_params, double(*rad_paramsd)[NB_DIRS_REPROJ_DV],
    double *proj, double (*projd)[NB_DIRS_REPROJ_DV], int nbdirs);
// cam 11 cameras in format [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]
//            r1, r2, r3 are angle - axis rotation parameters(Rodrigues)
//			  [C1 C2 C3]' is the camera center
//            f is the focal length in pixels
//			  [u0 v0]' is the principal point
//            k1, k2 are radial distortion parameters
// X 3 point
// proj 2 projection
// projection: 
// Xcam = R * (X - C)
// distorted = radial_distort(projective2euclidean(Xcam), radial_parameters)
// proj = distorted * f + principal_point
// err = sqsum(proj - measurement)
void project(double *cam, double *X, double *proj);
void project_dv(double *cam, double (*camd)[NB_DIRS_REPROJ_DV], double *X, double (*Xd
    )[NB_DIRS_REPROJ_DV], double *proj, double (*projd)[NB_DIRS_REPROJ_DV], int nbdirs);
void computeReprojError(double *cam, double *X, double *w, double feat_x, 
    double feat_y, double *err);
void computeReprojError_dv(double *cam, double (*camd)[NB_DIRS_REPROJ_DV], double *X, 
    double (*Xd)[NB_DIRS_REPROJ_DV], double *w, double (*wd)[NB_DIRS_REPROJ_DV], double feat_x
    , double feat_y, double *err, double (*errd)[NB_DIRS_REPROJ_DV], int nbdirs);

// temporal prior
void computeFocalPriorError(double *cam1, double *cam2, double *cam3, double *
	err);
void computeFocalPriorError_dv(double *cam1, double(*cam1d)[NB_DIRS_F_PRIOR_DV],
	double *cam2, double(*cam2d)[NB_DIRS_F_PRIOR_DV], double *cam3, double(*cam3d)[
		NB_DIRS_F_PRIOR_DV], double *err, double(*errd)[NB_DIRS_F_PRIOR_DV], int nbdirs);

void computeZachWeightError(double *w, double *err);
void computeZachWeightError_dv(double *w, double *wd, double *err
	, double *errd);

// n number of cameras
// m number of points
// p number of observations
// cams 11*n cameras in format [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]
//            r1, r2, r3 are angle - axis rotation parameters(Rodrigues)
//			  [C1 C2 C3]' is the camera center
//            f is the focal length in pixels
//			  [u0 v0]' is the principal point
//            k1, k2 are radial distortion parameters
// X 3*m points
// obs 2*p observations (pairs cameraIdx, pointIdx)
// feats 2*p features (x,y coordinates corresponding to observations)
// reproj_err 2*p errors of observations
// f_prior_err n-2 temporal prior on focals
// w_err p coputes like 1-w^2
// projection: 
// Xcam = R * (X - C)
// distorted = radial_distort(projective2euclidean(Xcam), radial_parameters)
// proj = distorted * f + principal_point
// err = sqsum(proj - measurement)
void ba_objective(int n, int m, int p, double *cams, double *X, double *w, int
    *obs, double *feats, double *reproj_err, double *f_prior_err, double *
    w_err);
